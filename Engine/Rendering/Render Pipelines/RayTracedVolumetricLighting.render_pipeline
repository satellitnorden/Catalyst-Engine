//Declare uniform buffer includes.
IncludeUniformBuffer(Camera);
IncludeUniformBuffer(General);
IncludeUniformBuffer(World);

//Declare storage buffer includes.
IncludeStorageBuffer(Lighting);

//Declare shader function library includes.
IncludeShaderFunctionLibrary(BlueNoise);
IncludeShaderFunctionLibrary(Camera);
IncludeShaderFunctionLibrary(Lighting);
IncludeShaderFunctionLibrary(Noise);
IncludeShaderFunctionLibrary(RenderingConfiguration);
IncludeShaderFunctionLibrary(VolumetricLighting);
IncludeShaderFunctionLibrary(World);

//Declare compute render targets.
ComputeRenderTarget(SceneFeatures2Half, RGBA_FLOAT32);
ComputeRenderTarget(VolumetricLighting, RGBA_FLOAT32);

//Declare samplers.
Sampler(SAMPLER /* Name */, LINEAR /* Magnification Filter */, LINEAR /* Mipmap Mode */, REPEAT /* Address Mode */, 8 /* Anisotropic Samples */);

//Subscribe to input streams.
SubscribeToInputStream(RayTracingViewportHalf);

//The ray generation shader.
RayGeneration
{
    //Declare payloads.
    Payload(0, float, VISIBILITY);

    //Constants.
    #define NUMBER_OF_SAMPLES (16)
    #define SAMPLE_RECIPROCAL (1.0f / NUMBER_OF_SAMPLES)

    //Calculate the start position.
    vec3 start_position = CAMERA_WORLD_POSITION;

    //Calculate the screen coordinate.
    vec2 screen_coordinate = (vec2(RAY_TRACING_ID.xy) + vec2(0.5f)) / vec2(RAY_TRACING_SIZE.xy);

    //Sample the scene features.
    vec4 scene_features_2 = ImageLoad(SceneFeatures2Half, ivec2(RAY_TRACING_ID.xy));

    //Cache properties.
    float depth = scene_features_2.w;

    //Calculate the world position.
    vec3 world_position = CalculateWorldPosition(screen_coordinate, depth);

    //Calculate the hit distance.
    float hit_distance = length(world_position - start_position);
	float hit_distance_reciprocal = 1.0f / hit_distance;

    //Modify the hit distance based on expected distance where we would reach below some threshold of transmittance.
    {
        #define TRANSMITTANCE_THRESHOLD (0.01f)

        float density_at_position = GetDensityAtPosition(start_position);

        if (density_at_position > FLOAT32_EPSILON)
        {
            float cutoff_distance = -log(TRANSMITTANCE_THRESHOLD) / density_at_position;
            hit_distance = min(hit_distance, cutoff_distance);
        }

        hit_distance = min(hit_distance, VOLUMETRIC_LIGHTING_HEIGHT);
    }

    //Generate the ray direction.
	vec3 ray_direction = (world_position - start_position) * hit_distance_reciprocal;

    //Set up the offsets.
    float offsets[NUMBER_OF_SAMPLES];

    for (uint offset_index = 0; offset_index < NUMBER_OF_SAMPLES; offset_index += 4)
    {
        vec4 blue_noise_texture_sample = SampleBlueNoiseTexture(uvec2(RAY_TRACING_ID.xy), offset_index / 4);
        
        offsets[offset_index + 0] = Square(blue_noise_texture_sample.x);
        offsets[offset_index + 1] = Square(blue_noise_texture_sample.y);
        offsets[offset_index + 2] = Square(blue_noise_texture_sample.z);
        offsets[offset_index + 3] = Square(blue_noise_texture_sample.w);
    }

    //Normalize the offsets.
    float offsets_sum = 0.0f;

    for (uint offset_index = 0; offset_index < NUMBER_OF_SAMPLES; ++offset_index)
    {
        offsets_sum += offsets[offset_index];
    }

    float offsets_normalizer = (1.0f - FLOAT32_EPSILON) / offsets_sum;

    for (uint offset_index = 0; offset_index < NUMBER_OF_SAMPLES; ++offset_index)
    {
        offsets[offset_index] *= offsets_normalizer;
    }

    //Calculate the volumetric lighting.
    float current_offset = 0.0f;
    
	vec3 volumetric_lighting = vec3(0.0f);
    float transmittance = 1.0f;

    for (uint sample_index = 0; sample_index < NUMBER_OF_SAMPLES; ++sample_index)
    {
        //Retrieve the sample offset.
        float sample_offset = offsets[sample_index];

        //Cache the previous offset.
        float previous_offset = current_offset;

        //Update the current offset.
        current_offset += sample_offset;

        //Calculate the previous position.
        vec3 previous_position = mix(start_position, world_position, previous_offset);

        //Calculate the sample position.
        vec3 sample_position = mix(start_position, world_position, current_offset);

        //Calculate the sample distance.
        float sample_distance = hit_distance * sample_offset;

        //Calculate the density at this the previous position.
        float density_at_previous_position = GetDensityAtPosition(previous_position);

        //Calculate the attenuation factor.
        float attenuation_factor = exp(-(density_at_previous_position * sample_distance));

        //Calculate the volumetric lighting at the position.
        vec3 volumetric_lighting_at_position = vec3(0.0f);

        //Add ambient lighting.
        {
            volumetric_lighting_at_position += UPPER_SKY_COLOR * VOLUMETRIC_LIGHTING_SCATTERING;
        }

        //Add direct lighting.
        for (uint light_index = 0; light_index < LIGHTING_HEADER._NumberOfLights; ++light_index)
        {
            //Unpack the light.
		    Light light = UnpackLight(light_index);

            //Only care if this light is volumetric.
            if (TEST_BIT(light._LightProperties, LIGHT_PROPERTY_VOLUMETRIC_BIT))
            {
                //Calculate the light radiance.
                vec3 light_radiance = light._Color * light._Intensity;

                vec3 scattering = light_radiance * VOLUMETRIC_LIGHTING_SCATTERING;

                {
                    //Reset the visibility.
                    VISIBILITY = 0.0f;

                    //Set up the ray tracing flags.
                    uint ray_tracing_flags =    RAY_TRACING_FLAG_TERMINATE_ON_FIRST_HIT
                                                | RAY_TRACING_FLAG_SKIP_CLOSEST_HIT;

                    //Calculate the direction.
                    vec3 direction = -light._TransformData1;

                    //Trace the ray!
                    TraceRay(ray_tracing_flags, 0, sample_position, direction, FLOAT32_MAXIMUM, 0);
                }

                scattering *= VISIBILITY;
                volumetric_lighting_at_position += scattering;
            }
        }

        //Accumulate the volumetric lighting.
        volumetric_lighting += volumetric_lighting_at_position * attenuation_factor;
        
        //Update the transmittance.
        transmittance *= attenuation_factor;
    }

    //Store the volumetric lighting.
    ImageStore(VolumetricLighting, ivec2(RAY_TRACING_ID.xy), vec4(volumetric_lighting, 1.0f - transmittance));
}

//The ray miss shader.
RayMiss
{
    //Declare payloads.
    Payload(0, float, VISIBILITY);

    //Set the visibility.
    VISIBILITY = 1.0f;
}

//Declare a new hit group.
HitGroup(MaskedModels);

//The ray any hit shader.
RayAnyHit
{
    //Retrieve the hit vertex information.
    HitVertexInformation hit_vertex_information = GetHitVertexInformation();

    //Retrieve the hit material index.
    uint hit_material_index = GetHitMaterialIndex();

    //Evaluate the opacity.
    float opacity;
    EVALUATE_OPACITY(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, opacity);

    //Check if this hit should be ignored.
    if (opacity < 0.5f)
    {
        IgnoreHit();
    }
}