//Declare uniform buffer includes.
IncludeUniformBuffer(Camera);
IncludeUniformBuffer(General);
IncludeUniformBuffer(HammersleyHemisphereSamples);
IncludeUniformBuffer(Irradiance);
IncludeUniformBuffer(World);

//Declare storage buffer includes.
IncludeStorageBuffer(Lighting);

//Declare shader function library includes.
IncludeShaderFunctionLibrary(BlueNoise);
IncludeShaderFunctionLibrary(Camera);
IncludeShaderFunctionLibrary(Lighting);
IncludeShaderFunctionLibrary(Math);
IncludeShaderFunctionLibrary(PhysicallyBasedLighting);
IncludeShaderFunctionLibrary(World);

//Declare compute render targets.
ComputeRenderTarget(SceneFeatures2Half, RGBA_FLOAT32);
ComputeRenderTarget(DiffuseIrradiance, RGBA_FLOAT32);

//Declare samplers.
Sampler(SAMPLER /* Name */, LINEAR /* Magnification Filter */, LINEAR /* Mipmap Mode */, REPEAT /* Address Mode */, 8 /* Anisotropic Samples */);

//Subscribe to input streams.
SubscribeToInputStream(RayTracingViewportHalf);

//The ray generation shader.
RayGeneration
{
    //Declare payloads.
    Payload(vec3, RADIANCE);

    //Calculate the screen coordinate.
    vec2 screen_coordinate = (vec2(RAY_TRACING_ID.xy) + vec2(0.5f)) / vec2(RAY_TRACING_SIZE.xy);

    //Sample the scene features.
    vec4 scene_features_2 = ImageLoad(SceneFeatures2Half, ivec2(RAY_TRACING_ID.xy));

    //Cache properties.
    vec3 normal = scene_features_2.xyz;
    float depth = scene_features_2.w;

    //Calculate the world position.
    vec3 world_position = CalculateWorldPosition(screen_coordinate, depth);

    //Sample the noise texture.
	vec4 noise_texture_sample = SampleBlueNoiseTexture(uvec2(RAY_TRACING_ID.xy), 0);

    //Initialize the random rotation.
    mat3 random_rotation = CalculateGramSchmidtRotationMatrix(normal, noise_texture_sample.xyz * 2.0f - 1.0f);

    //Calculate the random hemisphere sample index.
	uint random_hemisphere_sample_index = uint(noise_texture_sample.w * 64.0f) & 63;

    //Retrieve the random hemisphere sample.
    vec3 random_hemisphere_direction = IRRADIANCE_HEMISPHERE_SAMPLES[random_hemisphere_sample_index].xyz;
    
    //Rotate the random direction.
    vec3 random_direction = random_rotation * random_hemisphere_direction;

    //Flip the direction, if needed.
    random_direction = dot(random_direction, normal) >= 0.0f ? random_direction : -random_direction;

    //Trace the ray!
    TraceRay(0, 0, world_position, random_direction, FLOAT32_MAXIMUM);

    //Store the shadows.
    ImageStore(DiffuseIrradiance, ivec2(RAY_TRACING_ID.xy), vec4(RADIANCE, 1.0f));
}

//The ray miss shader.
RayMiss
{
    //Declare payloads.
    Payload(vec3, RADIANCE);

    //Set the radiance.
    RADIANCE = SampleSky(WORLD_RAY_DIRECTION, MAXIMUM_SKY_TEXTURE_MIP_LEVEL);
}

//Declare a new hit group.
HitGroup(OpaqueModels);

//The ray closest hit shader.
RayClosestHit
{
    //Declare payloads.
    Payload(vec3, RADIANCE);

    //Retrieve the hit vertex information.
    HitVertexInformation hit_vertex_information = GetHitVertexInformation();

    //Retrieve the hit material index.
    uint hit_material_index = GetHitMaterialIndex();

    //Evaluate the material.
    vec4 albedo_thickness;
    EVALUATE_ALBEDO_THICKNESS(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, albedo_thickness);
    vec4 normal_map_displacement;
    EVALUATE_NORMAL_MAP_DISPLACEMENT(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, normal_map_displacement);
    vec4 material_properties;
    EVALUATE_MATERIAL_PROPERTIES(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, material_properties);

    //Calculate the radiance.
    RADIANCE = vec3(0.0f, 0.0f, 0.0f);

    //Add emissive lighting.
    RADIANCE += albedo_thickness.rgb * material_properties.w * MATERIALS[hit_material_index]._EmissiveMultiplier;

    //Add direct lighting.
    {
        //Iterate over all lights.
        for (uint i = 0; i < LIGHTING_HEADER._NumberOfLights; ++i)
        {
            //Unpack the light.
	        Light light = UnpackLight(i);

            //Calculate the light radiance.
            vec3 light_radiance = light._Color * light._Intensity;

            switch (light._LightType)
            {
                case LIGHT_TYPE_DIRECTIONAL:
                {
                    //Accumulate light.
                    RADIANCE += CalculateDirectLighting
                    (
                        -WORLD_RAY_DIRECTION,
                        albedo_thickness.rgb,
                        hit_vertex_information._Normal,
                        material_properties.x,
                        material_properties.y,
                        material_properties.z,
                        albedo_thickness.w,
                        light._TransformData1,
                        light_radiance,
                        0
                    );

                    break;
                }
            }
        }
    }
}

//Declare a new hit group.
HitGroup(MaskedModels);

//The ray closest hit shader.
RayClosestHit
{
    //Declare payloads.
    Payload(vec3, RADIANCE);

    //Retrieve the hit vertex information.
    HitVertexInformation hit_vertex_information = GetHitVertexInformation();

    //Retrieve the hit material index.
    uint hit_material_index = GetHitMaterialIndex();

    //Evaluate the material.
    vec4 albedo_thickness;
    EVALUATE_ALBEDO_THICKNESS(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, albedo_thickness);
    vec4 normal_map_displacement;
    EVALUATE_NORMAL_MAP_DISPLACEMENT(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, normal_map_displacement);
    vec4 material_properties;
    EVALUATE_MATERIAL_PROPERTIES(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, material_properties);

    //Calculate the radiance.
    RADIANCE = vec3(0.0f, 0.0f, 0.0f);

    //Add emissive lighting.
    RADIANCE += albedo_thickness.rgb * material_properties.w * MATERIALS[hit_material_index]._EmissiveMultiplier;

    //Add direct lighting.
    {
        //Iterate over all lights.
        for (uint i = 0; i < LIGHTING_HEADER._NumberOfLights; ++i)
        {
            //Unpack the light.
	        Light light = UnpackLight(i);

            //Calculate the light radiance.
            vec3 light_radiance = light._Color * light._Intensity;

            switch (light._LightType)
            {
                case LIGHT_TYPE_DIRECTIONAL:
                {
                    //Add direct light.
                    RADIANCE += CalculateDirectLighting
                    (
                        -WORLD_RAY_DIRECTION,
                        albedo_thickness.rgb,
                        hit_vertex_information._Normal,
                        material_properties.x,
                        material_properties.y,
                        material_properties.z,
                        albedo_thickness.w,
                        light._TransformData1,
                        light_radiance,
                        0
                    );

                    break;
                }
            }
        }
    }
}

//The ray any hit shader.
RayAnyHit
{
    //Retrieve the hit vertex information.
    HitVertexInformation hit_vertex_information = GetHitVertexInformation();

    //Retrieve the hit material index.
    uint hit_material_index = GetHitMaterialIndex();

    //Evaluate the opacity.
    float opacity;
    EVALUATE_OPACITY(MATERIALS[hit_material_index], hit_vertex_information._TextureCoordinate, SAMPLER, opacity);

    //Check if this hit should be ignored.
    if (opacity < 0.5f)
    {
        IgnoreHit();
    }
}