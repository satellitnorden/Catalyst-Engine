//Declare unifom buffer includes.
IncludeUniformBuffer(Camera);

//Declare shader function library includes.
IncludeShaderFunctionLibrary(Camera);
IncludeShaderFunctionLibrary(Math);
IncludeShaderFunctionLibrary(Noise);
IncludeShaderFunctionLibrary(Terrain);

//Declare output depth buffer.
OutputDepthBuffer(SceneDepthBuffer);

//Declare output render targets.
OutputRenderTarget(SceneFeatures1);
OutputRenderTarget(SceneFeatures2);
OutputRenderTarget(SceneFeatures3);
OutputRenderTarget(SceneFeatures4);

//Declare render resolution.
RenderResolution(MAIN_FULL);

//Set the cull mode.
CullMode(BACK);

//Set the load/store operators.
DepthStencilLoadOperator(LOAD);
DepthStencilStoreOperator(STORE);
ColorLoadOperator(LOAD);
ColorStoreOperator(STORE);

//Set depth/stencil properties.
DepthCompareOperator(GREATER);
DepthTestEnable();
DepthWriteEnable();
StencilTestEnable();
StencilFailOperator(KEEP);
StencilPassOperator(REPLACE);
StencilDepthFailOperator(KEEP);
StencilCompareOperator(ALWAYS);
StencilCompareMask(0);
StencilWriteMask(1);
StencilReferenceMask(1);

//Set the topology.
Topology(TRIANGLE_LIST);

//Declare push constant data.
PushConstantData(vec2, WORLD_POSITION);
PushConstantData(vec2, MINIMUM_HEIGHT_MAP_COORDINATE);
PushConstantData(vec2, MAXIMUM_HEIGHT_MAP_COORDINATE);
PushConstantData(uint, BORDERS);
PushConstantData(float, PATCH_RESOLUTION_RECIPROCAL);
PushConstantData(float, PATCH_SIZE);
PushConstantData(uint, HEIGHT_MAP_TEXTURE_INDEX);
PushConstantData(uint, NORMAL_MAP_TEXTURE_INDEX);
PushConstantData(uint, INDEX_MAP_TEXTURE_INDEX);
PushConstantData(uint, BLEND_MAP_TEXTURE_INDEX);
PushConstantData(float, MAP_RESOLUTION);
PushConstantData(float, MAP_RESOLUTION_RECIPROCAL);

//Declare samplers.
Sampler(HEIGHT_MAP_SAMPLER /* Name */, NEAREST /* Magnification Filter */, NEAREST /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */, 0 /* Anisotropic Samples */);
Sampler(NORMAL_MAP_SAMPLER /* Name */, NEAREST /* Magnification Filter */, NEAREST /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */, 0 /* Anisotropic Samples */);
Sampler(INDEX_BLEND_MAP_SAMPLER /* Name */, NEAREST /* Magnification Filter */, NEAREST /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */, 0 /* Anisotropic Samples */);
Sampler(MATERIAL_SAMPLER /* Name */, LINEAR /* Magnification Filter */, LINEAR /* Mipmap Mode */, REPEAT /* Address Mode */, 8 /* Anisotropic Samples */);

//Subscribe to input streams.
SubscribeToInputStream(Terrain);

//The vertex shader.
Vertex
{
    //Declare input parameters.
    InputParameter(vec2, InPosition);
    InputParameter(uint, InBorders);

    //Declare output parameters.
    OutputParameter(vec3, OutWorldPosition);
    OutputParameter(vec2, OutHeightMapTextureCoordinate);

    //Calculate the stitched position.
    vec2 stitched_position = InPosition;

    //Apply the first layer of stiching.
    {
	    float is_left_multiplier = float((InBorders & BIT(0)) & (BORDERS & BIT(0)));
    	float is_right_multiplier = float((InBorders & BIT(2)) & (BORDERS & BIT(2)));
	    float vertical_offset = min(is_left_multiplier + is_right_multiplier, 1.0f);

        float is_down_multiplier = float((InBorders & BIT(4)) & (BORDERS & BIT(4)));
    	float is_up_multiplier = float((InBorders & BIT(6)) & (BORDERS & BIT(6)));
	    float horizontal_offset = min(is_down_multiplier + is_up_multiplier, 1.0f);

	    stitched_position.y -= PATCH_RESOLUTION_RECIPROCAL * vertical_offset;
	    stitched_position.x -= PATCH_RESOLUTION_RECIPROCAL * horizontal_offset;
    }

    //Apply the second layer of stiching.
    {
	    float is_left_multiplier = float((InBorders & BIT(1)) & (BORDERS & BIT(1)));
    	float is_right_multiplier = float((InBorders & BIT(3)) & (BORDERS & BIT(3)));
	    float vertical_offset = min(is_left_multiplier + is_right_multiplier, 1.0f);

        float is_down_multiplier = float((InBorders & BIT(5)) & (BORDERS & BIT(5)));
    	float is_up_multiplier = float((InBorders & BIT(7)) & (BORDERS & BIT(7)));
	    float horizontal_offset = min(is_down_multiplier + is_up_multiplier, 1.0f);

	    stitched_position.y -= (PATCH_RESOLUTION_RECIPROCAL * 2.0f) * vertical_offset;
	    stitched_position.x -= (PATCH_RESOLUTION_RECIPROCAL * 2.0f) * horizontal_offset;
    }

    //Calculate the height map coordinate.
    vec2 height_map_coordinate = vec2(mix(MINIMUM_HEIGHT_MAP_COORDINATE.x, MAXIMUM_HEIGHT_MAP_COORDINATE.x, stitched_position.x), mix(MINIMUM_HEIGHT_MAP_COORDINATE.y, MAXIMUM_HEIGHT_MAP_COORDINATE.y, stitched_position.y));

    //Calculate the world position.
    OutWorldPosition.x = WORLD_POSITION.x + mix(-(PATCH_SIZE * 0.5f), (PATCH_SIZE * 0.5f), stitched_position.x);
    OutWorldPosition.y = 0.0f;
    OutWorldPosition.z = WORLD_POSITION.y + mix(-(PATCH_SIZE * 0.5f), (PATCH_SIZE * 0.5f), stitched_position.y);

    //Sample the heightmap.
    {
        float height_1 = texture(sampler2D(TEXTURES[HEIGHT_MAP_TEXTURE_INDEX], HEIGHT_MAP_SAMPLER), height_map_coordinate + vec2(0.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).x;
        float height_2 = texture(sampler2D(TEXTURES[HEIGHT_MAP_TEXTURE_INDEX], HEIGHT_MAP_SAMPLER), height_map_coordinate + vec2(0.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).x;
        float height_3 = texture(sampler2D(TEXTURES[HEIGHT_MAP_TEXTURE_INDEX], HEIGHT_MAP_SAMPLER), height_map_coordinate + vec2(1.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).x;
        float height_4 = texture(sampler2D(TEXTURES[HEIGHT_MAP_TEXTURE_INDEX], HEIGHT_MAP_SAMPLER), height_map_coordinate + vec2(1.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).x;
    
        float blend_1 = mix(height_1, height_2, fract(height_map_coordinate.y * MAP_RESOLUTION));
	    float blend_2 = mix(height_3, height_4, fract(height_map_coordinate.y * MAP_RESOLUTION));

	    float final_height = mix(blend_1, blend_2, fract(height_map_coordinate.x * MAP_RESOLUTION));

        OutWorldPosition.y = final_height;
    }
    
    //Sample the normal map.
    vec3 normals[4];
    vec3 normal;

    {
        normals[0] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), height_map_coordinate + vec2(0.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[1] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), height_map_coordinate + vec2(0.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[2] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), height_map_coordinate + vec2(1.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[3] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), height_map_coordinate + vec2(1.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
    
        vec3 blend_1 = mix(normals[0], normals[1], fract(height_map_coordinate.y * MAP_RESOLUTION));
	    vec3 blend_2 = mix(normals[2], normals[3], fract(height_map_coordinate.y * MAP_RESOLUTION));

	    normal = mix(blend_1, blend_2, fract(height_map_coordinate.x * MAP_RESOLUTION));
        normal = normal * 2.0f - 1.0f;
        normal = normalize(normal);
    }

    //Calculate the heightmap texture coordinate.
    OutHeightMapTextureCoordinate = height_map_coordinate;

    //Apply displacement.
    {
        //Sample the displacements.
        float displacements[4];
        vec2 sample_offsets[4];
    
        sample_offsets[0] = vec2(0.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL;
        sample_offsets[1] = vec2(0.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL;
        sample_offsets[2] = vec2(1.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL;
        sample_offsets[3] = vec2(1.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL;

        for (uint i = 0; i < 4; ++i)
        {
            //Calculate the material texture coordinate.
            vec2 material_texture_coordinate = CalculateTerrainMaterialCoordinate(OutWorldPosition, (floor(OutHeightMapTextureCoordinate * MAP_RESOLUTION) + sample_offsets[i] * MAP_RESOLUTION) * TERRAIN_MATERIAL_SCALE, normals[i]);

            //Cache the height map texture coordinate.
            vec2 height_map_texture_coordinate = OutHeightMapTextureCoordinate + sample_offsets[i];

            //Sample the index map.
            vec4 index_map = texture(sampler2D(TEXTURES[INDEX_MAP_TEXTURE_INDEX], INDEX_BLEND_MAP_SAMPLER), height_map_texture_coordinate);
    
            //Retrieve the materials.
            Material material_1 = MATERIALS[uint(index_map[0] * float(UINT8_MAXIMUM))];
            Material material_2 = MATERIALS[uint(index_map[1] * float(UINT8_MAXIMUM))];
#if TERRAIN_SAMPLED_MATERIALS >= 3
            Material material_3 = MATERIALS[uint(index_map[2] * float(UINT8_MAXIMUM))];
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
            Material material_4 = MATERIALS[uint(index_map[3] * float(UINT8_MAXIMUM))];
#endif

            //Evaluate the normal map/displacement of the materials.
            vec4 normal_map_displacement_1;
            EVALUATE_NORMAL_MAP_DISPLACEMENT(material_1, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_1);
            vec4 normal_map_displacement_2;
            EVALUATE_NORMAL_MAP_DISPLACEMENT(material_2, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_2);
#if TERRAIN_SAMPLED_MATERIALS >= 3
            vec4 normal_map_displacement_3;
            EVALUATE_NORMAL_MAP_DISPLACEMENT(material_3, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_3);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
            vec4 normal_map_displacement_4;
            EVALUATE_NORMAL_MAP_DISPLACEMENT(material_4, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_4);
#endif

            normal_map_displacement_1.w = max(normal_map_displacement_1.w, TERRAIN_MINIMUM_DISPLACEMENT);
            normal_map_displacement_2.w = max(normal_map_displacement_2.w, TERRAIN_MINIMUM_DISPLACEMENT);
#if TERRAIN_SAMPLED_MATERIALS >= 3
            normal_map_displacement_3.w = max(normal_map_displacement_3.w, TERRAIN_MINIMUM_DISPLACEMENT);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
            normal_map_displacement_4.w = max(normal_map_displacement_4.w, TERRAIN_MINIMUM_DISPLACEMENT);
#endif

            //Sample the blend map.
            vec4 blend_map = texture(sampler2D(TEXTURES[BLEND_MAP_TEXTURE_INDEX], INDEX_BLEND_MAP_SAMPLER), height_map_texture_coordinate);

            //Alter the blend values based on the displacement.
            blend_map[0] *= BIAS_DISPLACEMENT(normal_map_displacement_1.w);
            blend_map[1] *= BIAS_DISPLACEMENT(normal_map_displacement_2.w);
#if TERRAIN_SAMPLED_MATERIALS >= 3
            blend_map[2] *= BIAS_DISPLACEMENT(normal_map_displacement_3.w);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
            blend_map[3] *= BIAS_DISPLACEMENT(normal_map_displacement_4.w);
#endif

            //Renormalize the blend map.
            float inverse_sum = 1.0f / 
            (
                blend_map[0]
                + blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
                + blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
                + blend_map[3]
#endif
            );

            blend_map[0] *= inverse_sum;
            blend_map[1] *= inverse_sum;
#if TERRAIN_SAMPLED_MATERIALS >= 3
            blend_map[2] *= inverse_sum;
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
            blend_map[3] *= inverse_sum;
#endif

            //Blend the material.
            displacements[i] =  normal_map_displacement_1.w * blend_map[0]
                                + normal_map_displacement_2.w * blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
                                + normal_map_displacement_3.w * blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
                                + normal_map_displacement_4.w * blend_map[3]
#endif
                                ;
        }

        //Calculate the blends.
        vec4 blends;
        
        blends[0] = (1.0f - fract(OutHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (1.0f - fract(OutHeightMapTextureCoordinate.y * MAP_RESOLUTION));
        blends[1] = (1.0f - fract(OutHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (fract(OutHeightMapTextureCoordinate.y * MAP_RESOLUTION));
        blends[2] = (fract(OutHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (1.0f - fract(OutHeightMapTextureCoordinate.y * MAP_RESOLUTION));
        blends[3] = (fract(OutHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (fract(OutHeightMapTextureCoordinate.y * MAP_RESOLUTION));

        //Alter the blend values based on the displacement.
        blends[0] *= BIAS_DISPLACEMENT(max(displacements[0], TERRAIN_MINIMUM_DISPLACEMENT));
        blends[1] *= BIAS_DISPLACEMENT(max(displacements[1], TERRAIN_MINIMUM_DISPLACEMENT));
        blends[2] *= BIAS_DISPLACEMENT(max(displacements[2], TERRAIN_MINIMUM_DISPLACEMENT));
        blends[3] *= BIAS_DISPLACEMENT(max(displacements[3], TERRAIN_MINIMUM_DISPLACEMENT));

        //Renormalize the blend map.
        float inverse_sum = 1.0f / (blends[0] + blends[1] + blends[2] + blends[3]);

        blends[0] *= inverse_sum;
        blends[1] *= inverse_sum;
        blends[2] *= inverse_sum;
        blends[3] *= inverse_sum;

        //Calculate the final displacement!
	    float final_displacement =  displacements[0] * blends[0]
                                    + displacements[1] * blends[1]
                                    + displacements[2] * blends[2]
                                    + displacements[3] * blends[3];

        //Apply the displacement!
        OutWorldPosition += normal * mix(-0.1875f, 0.25f, final_displacement); //Slight bias for upward displacement.
    }

    //Output the position.
    OutputVertexPosition(WORLD_TO_CLIP_MATRIX * vec4(OutWorldPosition, 1.0f));
}

//The fragment shader.
Fragment
{
    //Declare input parameters.
    InputParameter(vec3, InWorldPosition);
    InputParameter(vec2, InHeightMapTextureCoordinate);
    
    //Sample the normal map.
    vec3 normals[4];
    vec3 normal;

    {
        normals[0] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), InHeightMapTextureCoordinate + vec2(0.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[1] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), InHeightMapTextureCoordinate + vec2(0.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[2] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), InHeightMapTextureCoordinate + vec2(1.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
        normals[3] = texture(sampler2D(TEXTURES[NORMAL_MAP_TEXTURE_INDEX], NORMAL_MAP_SAMPLER), InHeightMapTextureCoordinate + vec2(1.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL).xyz;
    
        vec3 blend_1 = mix(normals[0], normals[1], fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));
	    vec3 blend_2 = mix(normals[2], normals[3], fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));

	    normal = mix(blend_1, blend_2, fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION));
        normal = normal * 2.0f - 1.0f;
        normal = normalize(normal);
    }

    mat3 tangent_space_matrix = CalculateGramSchmidtRotationMatrix(normal, vec3(0.0f, 0.0f, 1.0f));

    //Sample the terrain materials
    TerrainMaterial terrain_materials[4];
    vec2 sample_offsets[4];
    
    sample_offsets[0] = vec2(0.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL;
    sample_offsets[1] = vec2(0.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL;
    sample_offsets[2] = vec2(1.0f, 0.0f) * MAP_RESOLUTION_RECIPROCAL;
    sample_offsets[3] = vec2(1.0f, 1.0f) * MAP_RESOLUTION_RECIPROCAL;

    for (uint i = 0; i < 4; ++i)
    {
        //Calculate the material texture coordinate.
        vec2 material_texture_coordinate = CalculateTerrainMaterialCoordinate(InWorldPosition, (floor(InHeightMapTextureCoordinate * MAP_RESOLUTION) + sample_offsets[i] * MAP_RESOLUTION) * TERRAIN_MATERIAL_SCALE, normals[i]);

        //Cache the height map texture coordinate.
        vec2 height_map_texture_coordinate = InHeightMapTextureCoordinate + sample_offsets[i];

        //Sample the index map.
        vec4 index_map = texture(sampler2D(TEXTURES[INDEX_MAP_TEXTURE_INDEX], INDEX_BLEND_MAP_SAMPLER), height_map_texture_coordinate);
    
        //Retrieve the materials.
        Material material_1 = MATERIALS[uint(index_map[0] * float(UINT8_MAXIMUM))];
        Material material_2 = MATERIALS[uint(index_map[1] * float(UINT8_MAXIMUM))];
#if TERRAIN_SAMPLED_MATERIALS >= 3
        Material material_3 = MATERIALS[uint(index_map[2] * float(UINT8_MAXIMUM))];
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        Material material_4 = MATERIALS[uint(index_map[3] * float(UINT8_MAXIMUM))];
#endif

        //Evaluate the albedo/thickness of the materials.
        vec4 albedo_thickness_1;
        EVALUATE_ALBEDO_THICKNESS(material_1, material_texture_coordinate, MATERIAL_SAMPLER, albedo_thickness_1);
        vec4 albedo_thickness_2;
        EVALUATE_ALBEDO_THICKNESS(material_2, material_texture_coordinate, MATERIAL_SAMPLER, albedo_thickness_2);
#if TERRAIN_SAMPLED_MATERIALS >= 3
        vec4 albedo_thickness_3;
        EVALUATE_ALBEDO_THICKNESS(material_3, material_texture_coordinate, MATERIAL_SAMPLER, albedo_thickness_3);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        vec4 albedo_thickness_4;
        EVALUATE_ALBEDO_THICKNESS(material_4, material_texture_coordinate, MATERIAL_SAMPLER, albedo_thickness_4);
#endif

        //Evaluate the normal map/displacement of the materials.
        vec4 normal_map_displacement_1;
        EVALUATE_NORMAL_MAP_DISPLACEMENT(material_1, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_1);
        vec4 normal_map_displacement_2;
        EVALUATE_NORMAL_MAP_DISPLACEMENT(material_2, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_2);
#if TERRAIN_SAMPLED_MATERIALS >= 3
        vec4 normal_map_displacement_3;
        EVALUATE_NORMAL_MAP_DISPLACEMENT(material_3, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_3);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        vec4 normal_map_displacement_4;
        EVALUATE_NORMAL_MAP_DISPLACEMENT(material_4, material_texture_coordinate, MATERIAL_SAMPLER, normal_map_displacement_4);
#endif

        //Evaluate the material properties of the materials.
        vec4 material_properties_1;
        EVALUATE_MATERIAL_PROPERTIES(material_1, material_texture_coordinate, MATERIAL_SAMPLER, material_properties_1);
        vec4 material_properties_2;
        EVALUATE_MATERIAL_PROPERTIES(material_2, material_texture_coordinate, MATERIAL_SAMPLER, material_properties_2);
#if TERRAIN_SAMPLED_MATERIALS >= 3
        vec4 material_properties_3;
        EVALUATE_MATERIAL_PROPERTIES(material_3, material_texture_coordinate, MATERIAL_SAMPLER, material_properties_3);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        vec4 material_properties_4;
        EVALUATE_MATERIAL_PROPERTIES(material_4, material_texture_coordinate, MATERIAL_SAMPLER, material_properties_4);
#endif

        normal_map_displacement_1.w = max(normal_map_displacement_1.w, TERRAIN_MINIMUM_DISPLACEMENT);
        normal_map_displacement_2.w = max(normal_map_displacement_2.w, TERRAIN_MINIMUM_DISPLACEMENT);
#if TERRAIN_SAMPLED_MATERIALS >= 3
        normal_map_displacement_3.w = max(normal_map_displacement_3.w, TERRAIN_MINIMUM_DISPLACEMENT);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        normal_map_displacement_4.w = max(normal_map_displacement_4.w, TERRAIN_MINIMUM_DISPLACEMENT);
#endif

        //Sample the blend map.
        vec4 blend_map = texture(sampler2D(TEXTURES[BLEND_MAP_TEXTURE_INDEX], INDEX_BLEND_MAP_SAMPLER), height_map_texture_coordinate);

        //Alter the blend values based on the displacement.
        blend_map[0] *= BIAS_DISPLACEMENT(normal_map_displacement_1.w);
        blend_map[1] *= BIAS_DISPLACEMENT(normal_map_displacement_2.w);
#if TERRAIN_SAMPLED_MATERIALS >= 3
        blend_map[2] *= BIAS_DISPLACEMENT(normal_map_displacement_3.w);
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        blend_map[3] *= BIAS_DISPLACEMENT(normal_map_displacement_4.w);
#endif

        //Renormalize the blend map.
        float inverse_sum = 1.0f / 
        (
        blend_map[0]
        + blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
        + blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        + blend_map[3]
#endif
        );

        blend_map[0] *= inverse_sum;
        blend_map[1] *= inverse_sum;
#if TERRAIN_SAMPLED_MATERIALS >= 3
        blend_map[2] *= inverse_sum;
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
        blend_map[3] *= inverse_sum;
#endif

        //Blend the material.
        terrain_materials[i].albedo =   albedo_thickness_1.rgb * blend_map[0]
                                        + albedo_thickness_2.rgb * blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
                                        + albedo_thickness_3.rgb * blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
                                        + albedo_thickness_4.rgb * blend_map[3]
#endif
                                        ;

        terrain_materials[i].normal_map_displacement =  normal_map_displacement_1 * blend_map[0]
                                                        + normal_map_displacement_2 * blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
                                                        + normal_map_displacement_3 * blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
                                                        + normal_map_displacement_4 * blend_map[3]
#endif
                                                        ;

        terrain_materials[i].material_properties =  material_properties_1 * blend_map[0]
                                                    + material_properties_2 * blend_map[1]
#if TERRAIN_SAMPLED_MATERIALS >= 3
                                                    + material_properties_3 * blend_map[2]
#endif
#if TERRAIN_SAMPLED_MATERIALS >= 4
                                                    + material_properties_4 * blend_map[3]
#endif
                                                    ;
    }

    //Calculate the blends.
    vec4 blends;
        
    blends[0] = (1.0f - fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (1.0f - fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));
    blends[1] = (1.0f - fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));
    blends[2] = (fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (1.0f - fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));
    blends[3] = (fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION)) * (fract(InHeightMapTextureCoordinate.y * MAP_RESOLUTION));

    //Alter the blend values based on the displacement.
    blends[0] *= BIAS_DISPLACEMENT(max(terrain_materials[0].normal_map_displacement.w, TERRAIN_MINIMUM_DISPLACEMENT));
    blends[1] *= BIAS_DISPLACEMENT(max(terrain_materials[1].normal_map_displacement.w, TERRAIN_MINIMUM_DISPLACEMENT));
    blends[2] *= BIAS_DISPLACEMENT(max(terrain_materials[2].normal_map_displacement.w, TERRAIN_MINIMUM_DISPLACEMENT));
    blends[3] *= BIAS_DISPLACEMENT(max(terrain_materials[3].normal_map_displacement.w, TERRAIN_MINIMUM_DISPLACEMENT));

    //Renormalize the blend map.
    float inverse_sum = 1.0f / (blends[0] + blends[1] + blends[2] + blends[3]);

    blends[0] *= inverse_sum;
    blends[1] *= inverse_sum;
    blends[2] *= inverse_sum;
    blends[3] *= inverse_sum;

    //Calculate the final material!
    TerrainMaterial final_material;

    final_material.albedo = terrain_materials[0].albedo * blends[0]
                            + terrain_materials[1].albedo * blends[1]
                            + terrain_materials[2].albedo * blends[2]
                            + terrain_materials[3].albedo * blends[3];
    final_material.normal_map_displacement =    terrain_materials[0].normal_map_displacement * blends[0]
                                                + terrain_materials[1].normal_map_displacement * blends[1]
                                                + terrain_materials[2].normal_map_displacement * blends[2]
                                                + terrain_materials[3].normal_map_displacement * blends[3];
    final_material.material_properties =    terrain_materials[0].material_properties * blends[0]
                                            + terrain_materials[1].material_properties * blends[1]
                                            + terrain_materials[2].material_properties * blends[2]
                                            + terrain_materials[3].material_properties * blends[3];

    final_material.normal_map_displacement.xyz = final_material.normal_map_displacement.xyz * 2.0f - 1.0f;
	final_material.normal_map_displacement.xyz = normalize(final_material.normal_map_displacement.xyz);

    //Calculate the shading normal.
	vec3 shading_normal = normalize(tangent_space_matrix * final_material.normal_map_displacement.xyz);

    //Calculate the velocity.
    vec2 velocity = CalculateCurrentScreenCoordinate(InWorldPosition) - CalculatePreviousScreenCoordinate(InWorldPosition) - CURRENT_FRAME_JITTER;

    vec3 debug_albedo = vec3(fract(InHeightMapTextureCoordinate.x * MAP_RESOLUTION));

    //Output the fragments.
    OutputFragment(SceneFeatures1, vec4(mix(debug_albedo, final_material.albedo, 1.0f), 1.0f));
    OutputFragment(SceneFeatures2, vec4(shading_normal, gl_FragCoord.z));
    OutputFragment(SceneFeatures3, final_material.material_properties);
    OutputFragment(SceneFeatures4, vec4(velocity, 0.0f, 0.0f));
}