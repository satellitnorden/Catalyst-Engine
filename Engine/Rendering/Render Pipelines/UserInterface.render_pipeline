//Declare storage buffer includes.
IncludeStorageBuffer(UserInterface);

//Declare output render targets.
OutputRenderTarget(SceneLowDynamicRange1);

//Declare render resolution.
RenderResolution(MAIN_FULL);

//Set the cull mode.
CullMode(NONE);

//Set the load/store operators.
ColorLoadOperator(LOAD);
ColorStoreOperator(STORE);

//Set the topology.
Topology(TRIANGLE_FAN);

//Declare push constant data.
PushConstantData(mat4, TRANSFORMATION);

//Set blend properties.
BlendEnable();
BlendColorSourceFactor(SOURCE_ALPHA);
BlendColorDestinationFactor(ONE_MINUS_SOURCE_ALPHA);
BlendColorOperator(ADD);
BlendAlphaSourceFactor(ONE);
BlendAlphaDestinationFactor(ZERO);
BlendAlphaOperator(ADD);

//Declare samplers.
Sampler(SAMPLER /* Name */, LINEAR /* Magnification Filter */, LINEAR /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */, 0 /* Anisotropic Samples */);

//Subscribe to input streams.
SubscribeToInputStream(UserInterface);

//The vertex shader.
Vertex
{
    //Declare output parameters.
    OutputParameter(vec2, OutTextureCoordinate);
    OutputParameter(uint, OutInstanceIndex);

    //Retrieve the position and texture coordinate.
    vec4 position = USER_INTERFACE_INSTANCES[INSTANCE_INDEX]._Positions[VERTEX_INDEX];
    vec2 texture_coordinate = USER_INTERFACE_INSTANCES[INSTANCE_INDEX]._TextureCoordinates[VERTEX_INDEX];

    //Pass data to the fragment shader.
    OutTextureCoordinate = texture_coordinate;
    OutInstanceIndex = INSTANCE_INDEX;

    //Output the position.
    OutputVertexPosition(TRANSFORMATION * position);
}

//The fragment shader.
Fragment
{
    //Constants.
    #define SMOOTHING_FACTOR (0.325f)

    //Declare input parameters.
    InputParameter(vec2, InTextureCoordinate);
    InputParameter(uint, InInstanceIndex);

    //Retrieve the texture coordinate.
    vec2 texture_coordinate = InTextureCoordinate;

    //Flip if it's an image... (:
    if (TEST_BIT(USER_INTERFACE_INSTANCES[InInstanceIndex]._Flags, USER_INTERFACE_INSTANCE_FLAG_IMAGE))
    {
        texture_coordinate.y = 1.0f - texture_coordinate.y;
    }

    //Calculate the color.
    vec4 color;

    if (TEST_BIT(USER_INTERFACE_INSTANCES[InInstanceIndex]._Flags, USER_INTERFACE_INSTANCE_FLAG_TEXTURE))
    {
        color = texture(sampler2D(TEXTURES[USER_INTERFACE_INSTANCES[InInstanceIndex]._ColorOrTexture], SAMPLER), texture_coordinate);
    }

    else
    {
        color = UnpackColor(USER_INTERFACE_INSTANCES[InInstanceIndex]._ColorOrTexture);
    }

    //Special treatment for text.
    if (TEST_BIT(USER_INTERFACE_INSTANCES[InInstanceIndex]._Flags, USER_INTERFACE_INSTANCE_FLAG_TEXT))
    {
        //Calculate the opacity.
        float opacity = smoothstep(0.5f - SMOOTHING_FACTOR, 0.5f, color.x);

        //Set the color.
        color = vec4(1.0f, 1.0f, 1.0f, opacity);
    }

    //Unpack the color/opacity.
    vec4 color_opacity = UnpackColor(USER_INTERFACE_INSTANCES[InInstanceIndex]._ColorOpacity);

    //Apply the color/opacity.
    color *= color_opacity;

    //Output the fragments.
    OutputFragment(SceneLowDynamicRange1, color);
}