//Declare unifom buffer includes.
IncludeUniformBuffer(General);

//Declare shader function library includes.
IncludeShaderFunctionLibrary(PostProcess);

//Declare input render targets.
InputRenderTarget(InputRenderTarget /* Identifier */, NEAREST /* Magnification Filter */, NEAREST /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */);
InputRenderTarget(SceneFeatures2 /* Identifier */, NEAREST /* Magnification Filter */, NEAREST /* Mipmap Mode */, CLAMP_TO_EDGE /* Address Mode */);

//Declare output render targets.
OutputRenderTarget(OutputRenderTarget);

//Declare render resolution.
RenderResolution(MAIN_FULL);

//Set the load/store operators.
ColorStoreOperator(STORE);

//Set the topology.
Topology(TRIANGLE_FAN);

//Subscribe to input streams.
SubscribeToInputStream(Viewport);

//The vertex shader.
IncludeCommonVertexShader(ViewportScreenCoordinate);

//The fragment shader.
Fragment
{
    //Declare input parameters.
    InputParameter(vec2, InScreenCoordinate);

    //Gather the samples. Also keep track of the minimum/maximum luminance.
    vec3 samples[3][3];
    float minimum_luminance = 1.0f;
    float maximum_luminance = 0.0f;

    for (int Y = -1; Y <= 1; ++Y)
    {
        for (int X = -1; X <= 1; ++X)
        {
            vec2 sample_coordinate = InScreenCoordinate + vec2(X, Y) * INVERSE_FULL_MAIN_RESOLUTION;
            vec3 _sample = texture(InputRenderTarget, sample_coordinate).rgb;

            samples[X + 1][Y + 1] = _sample;

            float sample_luminance = PerceptualLuminance(_sample);
                    
            minimum_luminance = min(minimum_luminance, sample_luminance);
            maximum_luminance = max(maximum_luminance, sample_luminance);
        }
    }

    //Calculate the sharpen weight, based on the view_distance and luminance variance.
    float sharpen_weight = (1.0f - (maximum_luminance - minimum_luminance));

    sharpen_weight = smoothstep(0.9f, 1.0f, sharpen_weight);

    //Construct the kernel.
    float sharpen_kernel[3][3];

    sharpen_kernel[0][0] = sharpen_kernel[0][2] = sharpen_kernel[2][0] = sharpen_kernel[2][2] = -0.5f * sharpen_weight;
    sharpen_kernel[0][1] = sharpen_kernel[1][0] = sharpen_kernel[1][2] = sharpen_kernel[2][1] = -1.0f * sharpen_weight;
    sharpen_kernel[1][1] = 6.0f * sharpen_weight + 1.0f;

    //Construct the sharpened sample.
    vec3 sharpened_sample = vec3(0.0f);

    for (int Y = -1; Y <= 1; ++Y)
    {
        for (int X = -1; X <= 1; ++X)
        {
            sharpened_sample += samples[X + 1][Y + 1] * sharpen_kernel[X + 1][Y + 1];
        }
    }

    //Output the fragment.
#if 0
    vec3 output_fragment = vec3(0.0f);

    if (FRAGMENT_COORDINATE.x > 960.0f)
    {
        output_fragment = sharpened_sample;
        //output_fragment = vec3(sharpen_weight);
    }

    else
    {
        output_fragment = texture(InputRenderTarget, InScreenCoordinate).rgb;
    }

    output_fragment *= min(abs(FRAGMENT_COORDINATE.x - 960.0f) * 0.25f, 1.0f);

    OutputFragment(OutputRenderTarget, vec4(output_fragment, sharpen_weight));
#else
    OutputFragment(OutputRenderTarget, vec4(sharpened_sample, sharpen_weight));
#endif
}