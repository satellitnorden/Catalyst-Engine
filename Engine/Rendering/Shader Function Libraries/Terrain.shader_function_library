//Constants.
#define TERRAIN_SAMPLED_MATERIALS (4) //For performance. (:
#define TERRAIN_MINIMUM_DISPLACEMENT (0.0001f)
#define BIAS_DISPLACEMENT(X) (X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X)
#define TERRAIN_MATERIAL_SCALE (0.5f)

/*
*   Terrain material struct definition.
*/
struct TerrainMaterial
{
    vec3 albedo;
    vec4 normal_map_displacement;
    vec4 material_properties;
};

/*
*   Calculates the material coordinate for the given world position.
*/
vec2 CalculateTerrainMaterialCoordinate(vec3 world_position, vec2 tile_index, vec3 normal)
{
#if 1
    //Take the absolute of the normal.
    vec3 absolute_normal = abs(normal);

    //Calculate the tile.
    bool x_dominant = absolute_normal.x > absolute_normal.y && absolute_normal.x > absolute_normal.z;
    bool z_dominant = absolute_normal.z > absolute_normal.x && absolute_normal.z > absolute_normal.y;
    vec2 tile = world_position.yz * float(x_dominant) + world_position.xy * float(z_dominant) + world_position.xz * float(!x_dominant && !z_dominant);

    tile *= TERRAIN_MATERIAL_SCALE;

    //Calculate the random rotation.
    float random_rotation = mix(-PI, PI, RandomFloat(tile_index));

    //Randomly rotate the tile.
    tile -= tile_index;
    tile -= 0.5f;
    tile = RotateYaw(vec3(tile.x, 0.0f, tile.y), random_rotation).xz;
    tile += 0.5f;
    tile += tile_index;

    //Return the tile!
    return tile;
#else
    return vec2(world_position.x, world_position.z) * 0.5f;
#endif
}