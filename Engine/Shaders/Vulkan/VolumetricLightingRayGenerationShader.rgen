//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystLightingData.glsl"
#include "CatalystModelData.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystShaderPhysicallyBasedLighting.glsl"

//Descriptor set data.
layout (set = 3, binding = 0) uniform sampler2D sceneFeatures2Texture;
layout (set = 3, binding = 1, rgba32f) uniform image2D volumetricLightingImage;

//In parameters.
layout(location = 0) rayPayloadNV DiffuseIrradianceRayPayload rayPayload;
layout(location = 1) rayPayloadNV float visibility;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screenCoordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Load the scene features.
	vec4 sceneFeatures2 = texture(sceneFeatures2Texture, screenCoordinate);

	//Retrieve all properties.
	float hitDistance = sceneFeatures2.w;

	//Retrieve the random vectors.
	vec4 randomVector1 = texture(sampler2D(globalTextures[activeNoiseTextureIndex], globalSamplers[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));
	vec4 randomVector2 = texture(sampler2D(globalTextures[(activeNoiseTextureIndex + 1) & 63], globalSamplers[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));
	vec4 randomVector3 = texture(sampler2D(globalTextures[(activeNoiseTextureIndex + 2) & 63], globalSamplers[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));

	//Calculate the random directions.
	vec3 randomDirection1 = normalize(randomVector1.xyz * 2.0f - 1.0f);
	vec3 randomDirection2 = normalize(randomVector2.xyz * 2.0f - 1.0f);

	//Calculate the volumetric particle hit distance.
	float volumetricParticleHitDistance = hitDistance * randomVector1.w;

	//Calculate the ray direction.
	vec3 rayDirection = CalculateRayDirection(screenCoordinate);

	//Calculate the hit position.
	vec3 hitPosition = perceiverWorldPosition + rayDirection * volumetricParticleHitDistance;

	//Calculate the volumetric lighting.
	vec3 volumetricLighting = vec3(0.0f);

	//Calculate the indirect lighting.
	if (false)
	{
		//Set the random vector.
		rayPayload.randomVector = randomVector3;

		//Fire the ray!
		traceNV(
			topLevelAccelerationStructure, 		//topLevel
			gl_RayFlagsOpaqueNV, 				//rayFlags
			0xff, 								//cullMask
			0, 									//sbtRecordOffset
			0, 									//sbtRecordStride
			0, 									//missIndex
			hitPosition, 						//origin
			CATALYST_RAY_TRACING_T_MINIMUM, 	//Tmin
			randomDirection1, 					//direction
			CATALYST_RAY_TRACING_T_MAXIMUM, 	//Tmax
			0 									//payload
			);

		//Add the indirect lighting to the radiance.
		volumetricLighting += CalculateIndirectLighting(rayDirection,
														CATALYST_RAY_TRACING_VOLUMETRIC_LIGHTING_BASE_COLOR,
														randomDirection1,
														1.0f,
														0.0f,
														1.0f,
														rayPayload.directLighting,
														rayPayload.directLighting);
	}

	//Calculate the direct lighting.
	{
		//Calculate a random chosen light.
		Light light = UnpackLight(int(randomVector2.w * float(numberOfLights)));

		vec3 randomLightPosition = light.position + randomDirection2 * light.size;

		float lengthToLight = length(randomLightPosition - hitPosition);
		vec3 lightDirection = vec3(randomLightPosition - hitPosition) / lengthToLight;

		//Calculate the attenuation.
		float attenuation = 1.0f / (1.0f + lengthToLight + (lengthToLight * lengthToLight));

		//Determine the visibility.
		visibility = 0.0f;

		traceNV(
				topLevelAccelerationStructure, 																//topLevel
				gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
				0xff, 																						//cullMask
				0, 																							//sbtRecordOffset
				0, 																							//sbtRecordStride
				1, 																							//missIndex
				hitPosition, 																				//origin
				CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
				lightDirection,																				//direction
				lengthToLight,																				//Tmax
				1 																							//payload
				);

		volumetricLighting += CalculateDirectLight(	-rayDirection,
													lightDirection,
														CATALYST_RAY_TRACING_VOLUMETRIC_LIGHTING_BASE_COLOR,
													lightDirection,
													1.0f,
													0.0f,
													light.color * light.strength * float(numberOfLights)) * attenuation * visibility;
	}

	//Calculate the volumetric lighting weight.
	float volumetricLightingWeight = min(hitDistance / CATALYST_RAY_TRACING_T_MAXIMUM, 1.0f);

	//Write to the image.
	imageStore(volumetricLightingImage, ivec2(gl_LaunchIDNV.xy), vec4(volumetricLighting, volumetricLightingWeight));
	
}