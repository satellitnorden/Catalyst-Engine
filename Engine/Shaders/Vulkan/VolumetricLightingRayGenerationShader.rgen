//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystLightingData.glsl"
#include "CatalystPackingUtilities.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRayTracingData.glsl"
#include "CatalystRenderingUtilities.glsl"
#include "CatalystShaderPhysicallyBasedLighting.glsl"

//Constants.
#define CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR (vec3(0.6f, 0.8f, 1.0f))
#define CATALYST_VOLUMETRIC_LIGHTING_DENSITY_MULTIPLIER (0.125f)

//Descriptor set data.
layout (set = 3, binding = 0) uniform sampler2D scene_features_2_texture;
layout (set = 3, binding = 1, rgba32f) uniform image2D volumetric_lighting_image;

//In parameters.
layout(location = 1) rayPayloadNV float visibility;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screen_coordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Load the scene features.
	vec4 scene_features_2 = texture(scene_features_2_texture, screen_coordinate);

	//Retrieve all properties.
	vec3 world_position = CalculateWorldPosition(screen_coordinate, scene_features_2.w);
	float hit_distance = length(world_position - PERCEIVER_WORLD_POSITION);

	//Generate the ray direction.
	vec3 ray_direction = (world_position - PERCEIVER_WORLD_POSITION) / hit_distance;

	//Calculate the volumetric lighting.
	vec3 volumetric_lighting = vec3(0.0f);

	//Add the ambient lighting.
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(-1.0f, 0.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(1.0f, 0.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, -1.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 1.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 0.0f, -1.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 0.0f, 1.0f)).rgb * 0.167;

	//Sample the noise vector.
	vec4 noise_vector_1 = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));

	float samples_offsets[4];

	samples_offsets[0] = noise_vector_1[0];
	samples_offsets[1] = noise_vector_1[1];
	samples_offsets[2] = noise_vector_1[2];
	samples_offsets[3] = noise_vector_1[3];

	//Calculate the volumetric lighting for all lights.
	for (int i = 0; i < numberOfLights; ++i)
	{
		//Unpack the light.
		Light light = UnpackLight(i);

		switch (light.type)
		{
			case LIGHT_TYPE_DIRECTIONAL:
			{
				for (int j = 0; j < 4; ++j)
				{
					//Calculate the volumetric particle hit distance.
					float volumetric_particle_hit_distance = hit_distance * samples_offsets[j];

					//Calculate the volumetric particle hit position.
					vec3 volumetric_particle_hit_position = PERCEIVER_WORLD_POSITION + ray_direction * volumetric_particle_hit_distance;

					//Determine the visibility.
					bool hit_anything = false;

					visibility = 0.0f;

					traceNV(
							TERRAIN_TOP_LEVEL_ACCELERATION_STRUCTURE, 													//topLevel
							gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
							0xff, 																						//cullMask
							0, 																							//sbtRecordOffset
							0, 																							//sbtRecordStride
							0, 																							//missIndex
							volumetric_particle_hit_position, 															//origin
							CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
							-light.position_or_direction,																//direction
							VIEW_DISTANCE,																				//Tmax
							1 																							//payload
							);

					hit_anything = visibility < 1.0f;

					if (!hit_anything)
					{
						visibility = 0.0f;

						traceNV(
								STATIC_TOP_LEVEL_ACCELERATION_STRUCTURE, 													//topLevel
								gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
								0xff, 																						//cullMask
								0, 																							//sbtRecordOffset
								0, 																							//sbtRecordStride
								0, 																							//missIndex
								volumetric_particle_hit_position, 															//origin
								CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
								-light.position_or_direction,																//direction
								VIEW_DISTANCE,																				//Tmax
								1 																							//payload
								);

						hit_anything = visibility < 1.0f;

						if (!hit_anything)
						{
							visibility = 0.0f;

							traceNV(
									DYNAMIC_TOP_LEVEL_ACCELERATION_STRUCTURE, 													//topLevel
									gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
									0xff, 																						//cullMask
									0, 																							//sbtRecordOffset
									0, 																							//sbtRecordStride
									0, 																							//missIndex
									volumetric_particle_hit_position, 															//origin
									CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
									-light.position_or_direction,																//direction
									VIEW_DISTANCE,																				//Tmax
									1 																							//payload
									);

							hit_anything = visibility < 1.0f;
						}
					}

					//Add to the volumetric lighting.
					volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * light.luminance * CATALYST_VOLUMETRIC_LIGHTING_DENSITY_MULTIPLIER * 0.25f * float(!hit_anything);
				}

				break;
			}

			/*
			case LIGHT_TYPE_POINT:
			{
				//Sample the random vector.
				vec4 randomVector = texture(sampler2D(GLOBAL_TEXTURES[(activeNoiseTextureIndex + i) & 63], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));

				for (int j = 0; j < 4; ++j)
				{
					//Calculate the volumetric particle hit distance.
					float volumetricParticleHitDistance = hitDistance * randomVector[j];

					//Calculate the hit position.
					vec3 hitPosition = PERCEIVER_WORLD_POSITION + rayDirection * volumetricParticleHitDistance;

					float lengthToLight = length(light.position_or_direction - hitPosition);
					vec3 lightDirection = vec3(light.position_or_direction - hitPosition) / lengthToLight;

					//Calculate the attenuation.
					float attenuation = pow(1.0f / (1.0f + lengthToLight + (lengthToLight * lengthToLight)), 2.0f);

					//Determine the visibility.
					visibility = 0.0f;

					traceNV(
							STATIC_TOP_LEVEL_ACCELERATION_STRUCTURE, 													//topLevel
							gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
							0xff, 																						//cullMask
							0, 																							//sbtRecordOffset
							0, 																							//sbtRecordStride
							0, 																							//missIndex
							hitPosition, 																				//origin
							CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
							lightDirection,																				//direction
							lengthToLight,																				//Tmax
							1 																							//payload
							);

					//Add the direct lighting.
					volumetricLighting += CATALYST_RAY_TRACING_VOLUMETRIC_LIGHTING_BASE_COLOR * light.luminance * attenuation * visibility * 0.25f;
				}

				break;
			}
			*/
		}
	}

	//Write to the image.
	imageStore(volumetric_lighting_image, ivec2(gl_LaunchIDNV.xy), vec4(volumetric_lighting, 1.0f));
}