//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"

//Define constants.
#define SKY_CLOUDS_LOWER_PLANE (1024.0f * 2.0f)
#define SKY_CLOUDS_UPPER_PLANE (1024.0f * 8.0f)
#define SKY_CLOUDS_MAXIMUM_TRACE_DISTANCE (1024.0f)
#define SKY_CLOUDS_MAXIMUM_DISTANCE (1024.0f * 64.0f)

//Layout specification.
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) vec3 upper_sky_color;
	layout (offset = 16) vec3 lower_sky_color;
	layout (offset = 32) vec3 sky_light_direction;
	layout (offset = 48) vec3 sky_light_luminance;
	layout (offset = 64) uint current_iteration;
	layout (offset = 68) float parameters_difference;
	layout (offset = 72) float star_intensity;
};

/*
*	Calculates and returns the direction associated with this texel.
*/
vec3 CalculateDirection(uvec3 coordinate)
{	
	vec2 normalized_coordinates = (vec2(coordinate.xy) / (SKY_TEXTURE_BASE_RESOLUTION - 1)) * 2.0f - 1.0f;

	switch (coordinate.z)
	{
		case 0:
		{
			return normalize(vec3(-normalized_coordinates.x, -normalized_coordinates.y, 1.0f));
		}

		case 1:
		{
			return normalize(vec3(normalized_coordinates.x, -normalized_coordinates.y, -1.0f));
		}

		case 2:
		{
			return normalize(vec3(normalized_coordinates.y, 1.0f, normalized_coordinates.x));
		}

		case 3:
		{
			return normalize(vec3(-normalized_coordinates.y, -1.0f, normalized_coordinates.x));
		}

		case 4:
		{
			return normalize(vec3(1.0f, -normalized_coordinates.y, normalized_coordinates.x));
		}

		case 5:
		{
			return normalize(vec3(-1.0f, -normalized_coordinates.y, -normalized_coordinates.x));
		}
	}
}

/*
*	Calculates the sky.	
*/
vec3 CalculateSky(vec3 direction)
{
	//Calculate the upward factor.
	float upward_factor = dot(direction, vec3(0.0f, 1.0f, 0.0f)) * 0.5f + 0.5f;

	//Calculate the base sky color.
	vec3 base_sky_color = mix(lower_sky_color, upper_sky_color, upward_factor);

	//Calculate the sky light factor.
	float sky_light_factor = dot(direction, -sky_light_direction) * 0.5f + 0.5f;

	//Calculate the sky light color.
	vec3 sky_light_color = mix(base_sky_color, sky_light_luminance, sky_light_factor * 0.1f);

	//Bias the sky light factor a bit.
	sky_light_factor = pow(sky_light_factor, 4096.0f);

	//Calculate the final sky color.
	vec3 final_sky_color = mix(sky_light_color, sky_light_luminance, sky_light_factor);

	return base_sky_color;
}

/*
*	Calculates the stars.	
*/
vec4 CalculateStars(vec3 direction)
{
	if (star_intensity > 0.0f)
	{
		uint hash = Hash3(uvec3(floatBitsToUint(direction.x), floatBitsToUint(direction.y), floatBitsToUint(direction.z)));

		float star_weight = float((hash & 127) == 127) * star_intensity;

        return vec4(vec3(1.0f), star_weight);
	}
	
	else
	{
		return vec4(0.0f, 0.0f, 0.0f, 0.0f);
	}
}

/*
*	Calculates the clouds.
*/
vec4 CalculateClouds(uvec3 coordinate, vec3 direction)
{
	//Sample all of the noise samples.
	vec2 noise_texture_index = vec2(coordinate.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);

	vec4 noise_sample = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_index);

	//Do a line-plane intersection against the lower plane.
	float lower_plane_intersection_distance;

    LinePlaneIntersection(vec3(0.0f, 0.0f, 0.0f), direction, vec3(0.0f, SKY_CLOUDS_LOWER_PLANE, 0.0f), vec3(0.0f, -1.0f, 0.0f), lower_plane_intersection_distance);
    vec3 start = direction * lower_plane_intersection_distance;

	//Do a line-plane intersection against the upper plane.
	float upper_plane_intersection_distance;

    LinePlaneIntersection(vec3(0.0f, 0.0f, 0.0f), direction, vec3(0.0f, SKY_CLOUDS_UPPER_PLANE, 0.0f), vec3(0.0f, -1.0f, 0.0f), upper_plane_intersection_distance);
    vec3 end = direction * upper_plane_intersection_distance;

    //Retrieve the cloud density at some random points.
    float cloud_density = 0.0f;
    float cloud_density_in_direction = 0.0f;

    for (int i = 0; i < 4; i += 2)
    {
    	vec3 sample_point = mix(start, end, noise_sample[i + 0]);

    	cloud_density += SampleCloudDensity(sample_point, 3) * 4.0f;

    	vec3 sample_point_in_direction = sample_point + -sky_light_direction * SKY_CLOUDS_MAXIMUM_TRACE_DISTANCE * noise_sample[i + 1];

    	cloud_density_in_direction += SampleCloudDensity(sample_point_in_direction, 3);
    }

    //Calculate the cloud color.
    vec3 cloud_color = vec3(0.0f, 0.0f, 0.0f);

    //Start with some ambient lighting.
    cloud_color += CLOUD_BASE_COLOR * upper_sky_color * 0.125f + CLOUD_BASE_COLOR * lower_sky_color * 0.125f;

    //Proceed with the sky light lighting.
	cloud_color += CLOUD_BASE_COLOR * (sky_light_luminance * 0.1f) * exp(-cloud_density_in_direction);

	//Calculate the cloud density multiplier.
	float cloud_density_multiplier = 1.0f - clamp((lower_plane_intersection_distance - SKY_CLOUDS_LOWER_PLANE) / SKY_CLOUDS_MAXIMUM_DISTANCE, 0.0f, 1.0f);

    return vec4(cloud_color, min(cloud_density, 1.0f) * cloud_density_multiplier);
}

void main() 
{
	//Calculate the coordinate.
	uvec3 coordinate = uvec3(gl_GlobalInvocationID.xy * 2, gl_GlobalInvocationID.z);

	coordinate.x = coordinate.x + 1 * uint(current_iteration & 1);
	coordinate.y = coordinate.y + 1 * uint(current_iteration > 1);

	//Calculate the direction.
	vec3 direction = CalculateDirection(coordinate);

	//Calculate the sky color.
	vec3 sky_color = CalculateSky(direction);

	//Calculate the stars and blend them in.
	vec4 stars = CalculateStars(direction);

	sky_color = mix(sky_color, stars.rgb, stars.a);

	//Calculate the clouds.
	vec4 clouds;

	if (direction.y > 0.0f)
	{
		clouds = CalculateClouds(coordinate, direction);
	}

	else
	{
		clouds = vec4(0.0f, 0.0f, 0.0f, 0.0f);
	}

	//Load the old color.
	vec4 old_color = imageLoad(SKY_IMAGES[0], ivec3(coordinate));

	//Calculate the new color.
	vec4 new_color = vec4(mix(sky_color, clouds.rgb, clouds.a), 1.0f);

	//Calculate the final color.
	vec4 final_color = mix(new_color, old_color, 0.9f * (1.0f - parameters_difference));

	//Write to the image.
	imageStore(SKY_IMAGES[0], ivec3(coordinate), final_color);
}