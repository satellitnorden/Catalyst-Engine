//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"

//Define constants.
#define SKY_UPPER_COLOR (vec3(0.5f, 0.75f, 1.0f))
#define SKY_LOWER_COLOR (vec3(0.125f, 0.25f, 0.5f))
#define SKY_CLOUDS_UPPER_PLANE (1000.0f)

//Layout specification.
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) vec3 sky_light_direction;
	layout (offset = 16) vec3 sky_light_luminance;
	layout (offset = 32) uint resolution;
	layout (offset = 36) uint current_iteration;
	layout (offset = 40) float parameters_difference;
};

//Descriptor set data.
layout (set = 1, binding = 0, rgba32f) uniform imageCube sky_image;

/*
*	Calculates and returns the direction associated with this texel.
*/
vec3 CalculateDirection(uvec3 coordinate)
{	
	vec2 normalized_coordinates = (vec2(coordinate.xy) / (resolution + 1)) * 2.0f - 1.0f;

	switch (coordinate.z)
	{
		case 0:
		{
			return normalize(vec3(-normalized_coordinates.x, -normalized_coordinates.y, 1.0f));
		}

		case 1:
		{
			return normalize(vec3(normalized_coordinates.x, -normalized_coordinates.y, -1.0f));
		}

		case 2:
		{
			return normalize(vec3(normalized_coordinates.y, 1.0f, normalized_coordinates.x));
		}

		case 3:
		{
			return normalize(vec3(-normalized_coordinates.y, -1.0f, normalized_coordinates.x));
		}

		case 4:
		{
			return normalize(vec3(1.0f, -normalized_coordinates.y, normalized_coordinates.x));
		}

		case 5:
		{
			return normalize(vec3(-1.0f, -normalized_coordinates.y, -normalized_coordinates.x));
		}
	}
}

/*
*	Calculates the clouds.
*/
vec4 CalculateClouds(uvec3 coordinate, vec3 direction)
{
	//Sample all of the noise samples.
	vec2 noise_texture_index = vec2(coordinate.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);

	vec4 noise_sample = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_index);

	//Do a line-plane intersection against the upper plane.
	float intersection_distance;

    LinePlaneIntersection(vec3(0.0f, 0.0f, 0.0f), direction, vec3(0.0f, SKY_CLOUDS_UPPER_PLANE, 0.0f), vec3(0.0f, -1.0f, 0.0f), intersection_distance);
    vec3 end = direction * intersection_distance;

    //Retrieve the cloud density at a "random" point.
    float cloud_density = 0.0f;
    float cloud_density_in_direction = 0.0f;

    for (int i = 0; i < 4; i += 2)
    {
    	vec3 sample_point = mix(vec3(0.0f, 0.0f, 0.0f), end, noise_sample[i + 0]);

    	cloud_density += SampleCloudDensity(sample_point, 3) * 2.0f;

    	vec3 sample_point_in_direction = sample_point + -sky_light_direction * SKY_CLOUDS_UPPER_PLANE * noise_sample[i + 1];

    	cloud_density_in_direction += SampleCloudDensity(sample_point_in_direction, 3) * 4.0f;
    }

    //Calculate the cloud color.
    vec3 cloud_color = vec3(0.0f, 0.0f, 0.0f);

    //Start with some ambient lighting.
    cloud_color += CLOUD_BASE_COLOR * CalculateAmbientIlluminationIntensity() * 0.25f;

    //Proceed with the sky light lighting.
	cloud_color += CLOUD_BASE_COLOR * (sky_light_luminance * 0.1f) * exp(-cloud_density_in_direction);

    return vec4(cloud_color, 1.0f - exp(-cloud_density));
}

void main() 
{
	//Calculate the coordinate.
	uvec3 coordinate = uvec3(gl_GlobalInvocationID.xy * 2, gl_GlobalInvocationID.z);

	coordinate.x = coordinate.x + 1 * uint(current_iteration & 1);
	coordinate.y = coordinate.y + 1 * uint(current_iteration > 1);

	//Calculate the direction.
	vec3 direction = CalculateDirection(coordinate);

	//Calculate the upward factor.
	float upward_factor = dot(direction, vec3(0.0f, 1.0f, 0.0f)) * 0.5f + 0.5f;

	//Calculate the base sky color.
	vec3 base_sky_color = mix(SKY_LOWER_COLOR, SKY_UPPER_COLOR, upward_factor);

	//Calculate the sky light factor.
	float sky_light_factor = dot(direction, -sky_light_direction) * 0.5f + 0.5f;

	//Calculate the sky light color.
	vec3 sky_light_color = mix(base_sky_color, sky_light_luminance, sky_light_factor * 0.1f);

	//Bias the sky light factor a bit.
	sky_light_factor = pow(sky_light_factor, 4096.0f);

	//Calculate the final sky color.
	vec3 final_sky_color = mix(base_sky_color, sky_light_luminance, sky_light_factor);

	//Calculate the clouds.
	vec4 clouds;

	if (upward_factor > 0.5f)
	{
		clouds = CalculateClouds(coordinate, direction);
	}

	else
	{
		clouds = vec4(0.0f, 0.0f, 0.0f, 0.0f);
	}

	//Load the old color.
	vec4 old_color = imageLoad(sky_image, ivec3(coordinate));

	//Calculate the new color.
	vec4 new_color = vec4(mix(final_sky_color, clouds.rgb, clouds.a), 1.0f);

	//Calculate the final color.
	vec4 final_color = mix(new_color, old_color, 0.99f * (1.0f - parameters_difference));

	//Write to the image.
	imageStore(sky_image, ivec3(coordinate), final_color);
}