//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"

//Define constants.
#define SKY_CLOUDS_LOWER_PLANE (1024.0f * 2.0f)
#define SKY_CLOUDS_UPPER_PLANE (1024.0f * 8.0f)
#define SKY_CLOUDS_BASE_COLOR (vec3(0.8f, 0.9f, 1.0f))
#define SKY_CLOUDS_POSITION_SCALE (0.00001f)
#define SKY_CLOUDS_PERSISTENCE (0.5f) //0.025f step.
#define SKY_CLOUDS_LACUNARITY (3.5f) //0.25f step.
#define SKY_CLOUDS_MINIMUM_DENSITY (0.175f) //0.025f step.
#define SKY_CLOUDS_MAXIMUM_DENSITY (0.675f) //0.025f step.
#define SKY_CLOUDS_MAXIMUM_TRACE_DISTANCE (256.0f)
#define SKY_CLOUDS_SKY_LIGHT_LUMINANCE_MULTIPLIER (0.3f) //0.025f step.
#define SKY_CLOUDS_DENSITY_MULTIPLIER (16.0f) //0.25f step.

#define SKY_FEEDBACK_FACTOR (0.9875f) //0.0025f step.

//Layout specification.
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) vec3 upper_sky_color;
	layout (offset = 16) vec3 lower_sky_color;
	layout (offset = 32) vec3 sky_light_direction;
	layout (offset = 48) vec3 sky_light_luminance;
	layout (offset = 64) uint current_iteration;
	layout (offset = 68) float parameters_difference;
	layout (offset = 72) float star_intensity;
};

/*
*	Calculates and returns the direction associated with this texel.
*/
vec3 CalculateDirection(uvec3 coordinate)
{	
	vec2 normalized_coordinates = (vec2(coordinate.xy) / (SKY_TEXTURE_BASE_RESOLUTION - 1)) * 2.0f - 1.0f;

	switch (coordinate.z)
	{
		//Front.
		case 0:
		{
			return normalize(vec3(1.0f, -normalized_coordinates.y, -normalized_coordinates.x));
		}

		//Back.
		case 1:
		{
			return normalize(vec3(-1.0f, -normalized_coordinates.y, normalized_coordinates.x));
		}

		//Up.
		case 2:
		{
			return normalize(vec3(normalized_coordinates.x, 1.0f, normalized_coordinates.y));
		}

		//Down.
		case 3:
		{
			return normalize(vec3(normalized_coordinates.x, -1.0f, -normalized_coordinates.y));
		}

		//Right.
		case 4:
		{
			return normalize(vec3(normalized_coordinates.x, -normalized_coordinates.y, 1.0f));
		}

		//Left.
		case 5:
		{
			return normalize(vec3(-normalized_coordinates.x, -normalized_coordinates.y, -1.0f));
		}
	}
}

/*
*	Calculates the sky.	
*/
vec3 CalculateSky(vec3 direction)
{
	//Calculate the upward factor.
	float upward_factor = dot(direction, vec3(0.0f, 1.0f, 0.0f)) * 0.5f + 0.5f;

	//Calculate the base sky color.
	vec3 base_sky_color = mix(lower_sky_color, upper_sky_color, upward_factor);

	//Calculate the sky light factor.
	float sky_light_factor = max(dot(direction, -sky_light_direction) * 0.5f + 0.5f, 0.0f);

	//Calculate the sky light color.
	vec3 sky_light_color = mix(base_sky_color, sky_light_luminance, sky_light_factor * 0.01f);

	//Bias the sky light factor a bit.
	sky_light_factor = pow(sky_light_factor, 4096.0f);

	//Calculate the final sky color.
	vec3 final_sky_color = mix(sky_light_color, sky_light_luminance, sky_light_factor);

	return final_sky_color;
}

/*
*	Calculates the stars.	
*/
vec4 CalculateStars(vec3 direction)
{
	if (star_intensity > 0.0f)
	{
		uint hash = Hash3(uvec3(floatBitsToUint(direction.x), floatBitsToUint(direction.y), floatBitsToUint(direction.z)));

		float star_weight = float((hash & 127) == 127) * star_intensity;

        return vec4(vec3(1.0f), star_weight);
	}
	
	else
	{
		return vec4(0.0f, 0.0f, 0.0f, 0.0f);
	}
}

/*
*  Samples the cloud density at the given point.
*/
float SampleCloudDensity(vec3 point)
{
    //vec3 cloud_offset = -vec3(totalTime, totalTime * 0.1f, totalTime) * 16.0f;
    vec3 cloud_offset = vec3(0.0f, 0.0f, 0.0f);

    vec3 sample_point;
    float density_sample;
    float amplitude = 1.0f;
    float frequency = 1.0f;
    float total = 0.0f;
    float density = 0.0f;

    sample_point = ((point + (cloud_offset * SQUARE_ROOT_OF_TWO)) * frequency * SQUARE_ROOT_OF_TWO) * SKY_CLOUDS_POSITION_SCALE;
    density_sample = texture(CLOUD_TEXTURE, sample_point).x;
    density += density_sample * amplitude;
    total += amplitude;
    amplitude *= SKY_CLOUDS_PERSISTENCE;
    frequency *= SKY_CLOUDS_LACUNARITY;

    sample_point = ((point + (cloud_offset * HALF_PI)) * frequency * HALF_PI) * SKY_CLOUDS_POSITION_SCALE;
    density_sample = texture(CLOUD_TEXTURE, sample_point).y;
    density += density_sample * amplitude;
    total += amplitude;
    amplitude *= SKY_CLOUDS_PERSISTENCE;
    frequency *= SKY_CLOUDS_LACUNARITY;

    sample_point = ((point + (cloud_offset * PHI)) * frequency * PHI) * SKY_CLOUDS_POSITION_SCALE;
    density_sample = texture(CLOUD_TEXTURE, sample_point).z;
    density += density_sample * amplitude;
    total += amplitude;
    amplitude *= SKY_CLOUDS_PERSISTENCE;
    frequency *= SKY_CLOUDS_LACUNARITY;

    sample_point = ((point + (cloud_offset * EULERS_NUMBER)) * frequency * EULERS_NUMBER) * SKY_CLOUDS_POSITION_SCALE;
    density_sample = texture(CLOUD_TEXTURE, sample_point).w;
    density += density_sample * amplitude;
    total += amplitude;
    amplitude *= SKY_CLOUDS_PERSISTENCE;
    frequency *= SKY_CLOUDS_LACUNARITY;

    density /= total;

    density = max(density - (1.0f - mix(SKY_CLOUDS_MINIMUM_DENSITY, SKY_CLOUDS_MAXIMUM_DENSITY, CLOUD_DENSITY)), 0.0f);

    return density;
}

/*
*	Calculates the clouds.
*/
vec4 CalculateClouds(uvec3 coordinate, vec3 direction)
{
	//Sample all of the noise samples.
	vec2 noise_texture_index = vec2(coordinate.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);

	vec4 noise_sample_1 = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_index);
	vec4 noise_sample_2 = texture(sampler2D(GLOBAL_TEXTURES[(activeNoiseTextureIndex + 1) & 63], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_index);

	float noise_samples[8];

	noise_samples[0] = noise_sample_1[0];
	noise_samples[1] = noise_sample_1[1];
	noise_samples[2] = noise_sample_1[2];
	noise_samples[3] = noise_sample_1[3];
	noise_samples[4] = noise_sample_2[0];
	noise_samples[5] = noise_sample_2[1];
	noise_samples[6] = noise_sample_2[2];
	noise_samples[7] = noise_sample_2[3];

	//Calculate the start and end
    vec3 start = direction * SKY_CLOUDS_LOWER_PLANE;
    vec3 end = direction * SKY_CLOUDS_UPPER_PLANE;

    //Retrieve the cloud density at some random points.
    float cloud_density = 0.0f;
    float cloud_density_in_direction = 0.0f;

    for (int i = 0; i < 8; i += 2)
    {
    	vec3 sample_point = mix(start, end, noise_samples[i + 0]);

    	cloud_density += SampleCloudDensity(sample_point) * SKY_CLOUDS_DENSITY_MULTIPLIER;

    	vec3 sample_point_in_direction = sample_point + -sky_light_direction * SKY_CLOUDS_MAXIMUM_TRACE_DISTANCE * noise_samples[i + 1];

    	cloud_density_in_direction += SampleCloudDensity(sample_point_in_direction) * SKY_CLOUDS_DENSITY_MULTIPLIER;
    }

    //Calculate the cloud color.
    vec3 cloud_color = vec3(0.0f, 0.0f, 0.0f);

    //Start with some ambient lighting.
    cloud_color += SKY_CLOUDS_BASE_COLOR * upper_sky_color * 0.125f + SKY_CLOUDS_BASE_COLOR * lower_sky_color * 0.125f;

    //Proceed with the sky light lighting.
	cloud_color += SKY_CLOUDS_BASE_COLOR * (sky_light_luminance * SKY_CLOUDS_SKY_LIGHT_LUMINANCE_MULTIPLIER) * exp(-cloud_density_in_direction);

    return vec4(cloud_color, min(cloud_density, 1.0f));
}

void main() 
{
	//Calculate the coordinate.
	uvec3 coordinate = uvec3(gl_GlobalInvocationID.xy * 2, gl_GlobalInvocationID.z);

	coordinate.x = coordinate.x + 1 * uint(current_iteration & 1);
	coordinate.y = coordinate.y + 1 * uint(current_iteration > 1);

	//Calculate the direction.
	vec3 direction = CalculateDirection(coordinate);

	//Calculate the sky color.
	vec3 sky_color = CalculateSky(direction);

	//Calculate the stars and blend them in.
	vec4 stars = CalculateStars(direction);

	sky_color = mix(sky_color, stars.rgb, stars.a);

	//Calculate the clouds.
	vec4 clouds = CalculateClouds(coordinate, direction);

	//Load the old color.
	vec4 old_color = imageLoad(SKY_IMAGES[0], ivec3(coordinate));

	//Calculate the new color.
	vec4 new_color = vec4(mix(sky_color, clouds.rgb, clouds.a), 1.0f);

	//Calculate the final color.
	vec4 final_color = mix(new_color, old_color, SKY_FEEDBACK_FACTOR * (1.0f - parameters_difference));

	//Write to the image.
	imageStore(SKY_IMAGES[0], ivec3(coordinate), final_color);
}