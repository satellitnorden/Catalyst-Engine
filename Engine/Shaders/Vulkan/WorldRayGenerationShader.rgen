//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystToneMappingUtilities.glsl"

//Descriptor set data.
layout (set = 1, binding = 0, rgba32f) uniform image2D indirectLightingImage;
layout (set = 1, binding = 1, rgba32f) uniform image2D directLightingImage;
layout (set = 1, binding = 2, rgba32f) uniform image2D sceneFeatures1Image;
layout (set = 1, binding = 3, rgba32f) uniform image2D sceneFeatures2Image;
layout (set = 1, binding = 4) uniform accelerationStructureNV topLevelAccelerationStructure;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) int numberOfIterations;
	layout (offset = 4) int currentIteration;

    layout (offset = 8) float seed1;
    layout (offset = 12) float seed2;
    layout (offset = 16) float seed3;
    layout (offset = 20) float seed4;
    layout (offset = 24) float seed5;
    layout (offset = 28) float seed6;
    layout (offset = 32) float seed7;
};

//In parameters.
layout(location = 0) rayPayloadNV RayPayload rayPayload;

void main() 
{
	//Inidicate that this is the top recursion level.
	rayPayload.currentRecursionDepth = 0;

	traceNV(
			topLevelAccelerationStructure, 																//topLevel
			gl_RayFlagsOpaqueNV, 																		//rayFlags
			0xff, 																						//cullMask
			0, 																							//sbtRecordOffset
			0, 																							//sbtRecordStride
			0, 																							//missIndex
			perceiverWorldPosition, 																	//origin
			CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
			CalculateRayDirection((vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy)), 	//direction
			CATALYST_RAY_TRACING_T_MAXIMUM, 															//Tmax
			0 																							//payload
			);

	if (currentIteration == 0)
    {
    	imageStore(indirectLightingImage, ivec2(gl_LaunchIDNV.xy), vec4(ToneMap(rayPayload.indirectLighting), 1.0f) / numberOfIterations);
    	imageStore(directLightingImage, ivec2(gl_LaunchIDNV.xy), vec4(ToneMap(rayPayload.directLighting), 1.0f) / numberOfIterations);
    	imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.normal, rayPayload.depth) / numberOfIterations);
    	imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.roughness, rayPayload.metallic, rayPayload.ambientOcclusion, 1.0f) / numberOfIterations);
    }

    else
    {
    	vec4 previousIndirectLighting = imageLoad(indirectLightingImage, ivec2(gl_LaunchIDNV.xy));
    	vec4 previousDirectLighting = imageLoad(directLightingImage, ivec2(gl_LaunchIDNV.xy));
    	vec4 previousSceneFeatures1 = imageLoad(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy));
    	vec4 previousSceneFeatures2 = imageLoad(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy));

    	imageStore(indirectLightingImage, ivec2(gl_LaunchIDNV.xy), previousIndirectLighting + vec4(ToneMap(rayPayload.indirectLighting), 1.0f) / numberOfIterations);
    	imageStore(directLightingImage, ivec2(gl_LaunchIDNV.xy), previousDirectLighting + vec4(ToneMap(rayPayload.directLighting), 1.0f) / numberOfIterations);
    	imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), previousSceneFeatures1 + vec4(rayPayload.normal, rayPayload.depth) / numberOfIterations);
    	imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), previousSceneFeatures2 + vec4(rayPayload.roughness, rayPayload.metallic, rayPayload.ambientOcclusion, 1.0f) / numberOfIterations);
    }
}
