//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystPackingUtilities.glsl"
#include "CatalystRayTracingCore.glsl"

//Descriptor set data.
layout (set = 1, binding = 0, rgba32f) uniform image2D diffuseIrradianceImage;
layout (set = 1, binding = 1, rgba32f) uniform image2D specularIrradianceImage;
layout (set = 1, binding = 2, rgba8) uniform image2D sceneFeatures1Image;
layout (set = 1, binding = 3, rgba32f) uniform image2D sceneFeatures2Image;
layout (set = 1, binding = 4, rgba8) uniform image2D sceneFeatures3Image;
layout (set = 1, binding = 5, rgba32f) uniform image2D sceneFeatures4Image;
layout (set = 1, binding = 6) uniform sampler2D noiseImage;
layout (set = 1, binding = 7) uniform accelerationStructureNV topLevelAccelerationStructure;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) ivec2 noiseOffset;
};

//In parameters.
layout(location = 0) rayPayloadNV PrimaryRayPayload rayPayload;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screenCoordinate = vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy);

	//Retrieve the random vector.
#define USE_NOISE_TEXTURE true

#if USE_NOISE_TEXTURE
	rayPayload.randomVector = normalize(texture(noiseImage, vec2((gl_LaunchIDNV.x + noiseOffset.x) & 31, (gl_LaunchIDNV.y + noiseOffset.y) & 31) / vec2(32.0f, 32.0f)).xyz * 2.0f - 1.0f);
#else
	rayPayload.randomVector = normalize(vec3(	RandomFloat(screenCoordinate, globalRandomSeed1) * 2.0f - 1.0f,
												RandomFloat(screenCoordinate, globalRandomSeed2) * 2.0f - 1.0f,
												RandomFloat(screenCoordinate, globalRandomSeed3) * 2.0f - 1.0f));
#endif

	//Inidicate that this is the top recursion level.
	rayPayload.currentRecursionDepth = 0;

	//Generate the ray direction.
	vec3 rayDirection = CalculateRayDirection(screenCoordinate);

	traceNV(
			topLevelAccelerationStructure, 	//topLevel
			gl_RayFlagsOpaqueNV, 			//rayFlags
			0xff, 							//cullMask
			0, 								//sbtRecordOffset
			0, 								//sbtRecordStride
			0, 								//missIndex
			perceiverWorldPosition, 		//origin
			CATALYST_RAY_TRACING_T_MINIMUM, //Tmin
			rayDirection, 					//direction
			CATALYST_RAY_TRACING_T_MAXIMUM, //Tmax
			0 								//payload
			);

	imageStore(diffuseIrradianceImage, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.diffuseIrradiance, 1.0f));
	imageStore(specularIrradianceImage, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.specularIrradiance, 1.0f));
    imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.albedo, 1.0f));
    imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), vec4(PackNormal(rayPayload.geometryNormal), PackNormal(rayPayload.shadingNormal), rayPayload.depth, intBitsToFloat(rayPayload.materialProperties)));
    imageStore(sceneFeatures3Image, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.roughness, rayPayload.metallic, rayPayload.ambientOcclusion, rayPayload.emissive));
    imageStore(sceneFeatures4Image, ivec2(gl_LaunchIDNV.xy), vec4(intBitsToFloat(rayPayload.instanceID), intBitsToFloat(rayPayload.primitiveID), rayPayload.barycentricCoordinates.x, rayPayload.barycentricCoordinates.y));
}
