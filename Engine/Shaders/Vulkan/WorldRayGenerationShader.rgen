//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystPackingUtilities.glsl"
#include "CatalystRayTracingCore.glsl"

//Constants.
#define SAMPLES (1)
vec2 JITTER_OFFSETS[16] = vec2[]
(
	vec2(-0.25f, -0.25f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(-0.25f, 0.25f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.25f, -0.25f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.25f, 0.25f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),

	vec2(-0.5f, -0.5f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(-0.5f, 0.5f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.5f, -0.5f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.5f, 0.5f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),

	vec2(-0.75f, -0.75f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(-0.75f, 0.75f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.75f, -0.75f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(0.75f, 0.75f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),

	vec2(-1.0f, -1.0f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(-1.0f, 1.0f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(1.0f, -1.0f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f),
	vec2(1.0f, 1.0f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f)
);
ivec2 SAMPLE_OFFSETS[16] = ivec2[]
(
	ivec2(0, 0),
	ivec2(1, 0),
	ivec2(1, 1),
	ivec2(0, 1),

	ivec2(2, 0),
	ivec2(2, 1),
	ivec2(2, 2),
	ivec2(1, 2),
	ivec2(0, 2),

	ivec2(3, 0),
	ivec2(3, 1),
	ivec2(3, 2),
	ivec2(3, 3),
	ivec2(2, 3),
	ivec2(1, 3),
	ivec2(0, 3)
);

//Descriptor set data.
layout (set = 1, binding = 0, rgba32f) uniform image2D indirectLightingImage;
layout (set = 1, binding = 1, rgba32f) uniform image2D directLightingImage;
layout (set = 1, binding = 2, rgba32f) uniform image2D sceneFeatures1Image;
layout (set = 1, binding = 3, rgba32f) uniform image2D sceneFeatures2Image;
layout (set = 1, binding = 4, rgba8) uniform image2D sceneFeatures3Image;
layout (set = 1, binding = 5) uniform sampler2D noiseImage;
layout (set = 1, binding = 6) uniform accelerationStructureNV topLevelAccelerationStructure;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) ivec2 noiseOffset;
};

//In parameters.
layout(location = 0) rayPayloadNV PrimaryRayPayload rayPayload;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screenCoordinate = vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy);

	//Accumulate results.
	vec3 indirectLighting = vec3(0.0f);
	vec3 directLighting = vec3(0.0f);
	vec3 albedo = vec3(0.0f);
	vec3 geometryNormal = vec3(0.0f);
	vec3 shadingNormal = vec3(0.0f);
	float depth = 0.0f;
	int materialProperties = 0;
	float roughness = 0.0f;
	float metallic = 0.0f;
	float ambientOcclusion = 0.0f;
	float luminance = 0.0f;

	for (int i = 0; i < SAMPLES; ++i)
	{
		//Retrieve the random vector.
		rayPayload.randomVector = texture(noiseImage, vec2((gl_LaunchIDNV.x + noiseOffset.x + SAMPLE_OFFSETS[i].x) & 63, (gl_LaunchIDNV.y + noiseOffset.y + SAMPLE_OFFSETS[i].y) & 63) / vec2(64.0f, 64.0f));

		//Jitter the screen coordinate a bit to get some anti-aliasing.
		vec2 jitteredScreenCoordinate;

		if (SAMPLES > 2)
		{
			jitteredScreenCoordinate = screenCoordinate + JITTER_OFFSETS[i];
		}

		else
		{
			jitteredScreenCoordinate = screenCoordinate;
		}

		//jitteredScreenCoordinate = screenCoordinate + vec2(RandomFloat(screenCoordinate, globalRandomSeed1) * 2.0f - 1.0f, RandomFloat(screenCoordinate, globalRandomSeed2) * 2.0f - 1.0f) * vec2(1.0f / 1920.0f, 1.0f / 1080.0f);

		//Normalize the first three elements of the random vector.
		rayPayload.randomVector.xyz = normalize(rayPayload.randomVector.xyz * 2.0f - 1.0f);

		//Inidicate that this is the top recursion level.
		rayPayload.currentRecursionDepth = 0;

		//Generate the ray direction.
		vec3 rayDirection = CalculateRayDirection(jitteredScreenCoordinate);

		traceNV(
				topLevelAccelerationStructure, 	//topLevel
				gl_RayFlagsOpaqueNV, 			//rayFlags
				0xff, 							//cullMask
				0, 								//sbtRecordOffset
				0, 								//sbtRecordStride
				0, 								//missIndex
				perceiverWorldPosition, 		//origin
				CATALYST_RAY_TRACING_T_MINIMUM, //Tmin
				rayDirection, 					//direction
				CATALYST_RAY_TRACING_T_MAXIMUM, //Tmax
				0 								//payload
				);

		//Accumulate the results.
		indirectLighting += rayPayload.indirectLighting / SAMPLES;
		directLighting += rayPayload.directLighting / SAMPLES;
		albedo += rayPayload.albedo / SAMPLES;
		geometryNormal += rayPayload.geometryNormal / SAMPLES;
		shadingNormal += rayPayload.shadingNormal / SAMPLES;
		depth += rayPayload.depth / SAMPLES;
		materialProperties += rayPayload.materialProperties / SAMPLES;
		roughness += rayPayload.roughness / SAMPLES;
		metallic += rayPayload.metallic / SAMPLES;
		ambientOcclusion += rayPayload.ambientOcclusion / SAMPLES;
		luminance += rayPayload.luminance / SAMPLES;
	}

	//Write to the images.
	imageStore(indirectLightingImage, ivec2(gl_LaunchIDNV.xy), vec4(indirectLighting, 1.0f));
	imageStore(directLightingImage, ivec2(gl_LaunchIDNV.xy), vec4(directLighting, 1.0f));
    imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), vec4(albedo, 1.0f));
    imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), vec4(PackNormal(geometryNormal), PackNormal(shadingNormal), depth, intBitsToFloat(materialProperties)));
    imageStore(sceneFeatures3Image, ivec2(gl_LaunchIDNV.xy), vec4(roughness, metallic, ambientOcclusion, luminance));
}
