//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystRayTracingCore.glsl"

//Constants.
#define NUMBER_OF_ITERATIONS (2)
#define INVERSE_NUMBER_OF_ITERATIONS (1.0f / NUMBER_OF_ITERATIONS)

//Descriptor set data.
layout (set = 1, binding = 0, rgba32f) uniform image2D image;
layout (set = 1, binding = 1) uniform accelerationStructureNV topLevelAccelerationStructure;

//Push constant data.
layout (push_constant) uniform PushConstantData
{
	layout (offset = 0) int iteration;

    layout (offset = 4) float seed1;
    layout (offset = 8) float seed2;
    layout (offset = 12) float seed3;
    layout (offset = 16) float seed4;
    layout (offset = 20) float seed5;
    layout (offset = 24) float seed6;
    layout (offset = 28) float seed7;
    layout (offset = 32) float seed8;
    layout (offset = 36) float seed9;
};

//In parameters.
layout(location = 0) rayPayloadNV RayPayload rayPayload;

/*
*	Calculates the direction.
*/
vec3 CalculateDirection()
{
	vec2 center = vec2(gl_LaunchIDNV.xy) + vec2(0.5f);
    vec2 textureCoordinate = center / vec2(gl_LaunchSizeNV.xy);
    vec2 nearPlaneCoordinate = textureCoordinate * 2.0f - 1.0f;
	vec4 viewSpacePosition = inverseProjectionMatrix * vec4(vec3(nearPlaneCoordinate, 1.0f), 1.0f);
	float inverseViewSpacePositionDenominator = 1.0f / viewSpacePosition.w;
	viewSpacePosition *= inverseViewSpacePositionDenominator;
	vec4 worldSpacePosition = inversePerceiverMatrix * viewSpacePosition;

	vec3 worldPosition = vec3(worldSpacePosition.x, worldSpacePosition.y, worldSpacePosition.z);

	vec3 randomPosition = normalize(vec3(	RandomFloat(vec3(gl_LaunchIDNV.xy, seed1)),
											RandomFloat(vec3(gl_LaunchIDNV.xy, seed2)),
											RandomFloat(vec3(gl_LaunchIDNV.xy, seed3)))) * 0.0000625f; //0.0000025f step

	return normalize(worldPosition + randomPosition - perceiverWorldPosition);
}

void main() 
{
	//Inidicate that this is the top recursion level.
	rayPayload.currentRecursionDepth = 0;

	traceNV(
			topLevelAccelerationStructure, 	//topLevel
			gl_RayFlagsOpaqueNV, 			//rayFlags
			0xff, 							//cullMask
			0, 								//sbtRecordOffset
			0, 								//sbtRecordStride
			0, 								//missIndex
			perceiverWorldPosition, 		//origin
			CATALYST_RAY_TRACING_T_MINIMUM, //Tmin
			CalculateDirection(), 			//direction
			CATALYST_RAY_TRACING_T_MAXIMUM, //Tmax
			0 								//payload
			);

	if (iteration == 0)
    {
    	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(rayPayload.radiance * INVERSE_NUMBER_OF_ITERATIONS, 1.0f));
    }

    else
    {
    	vec4 previousRadiance = imageLoad(image, ivec2(gl_LaunchIDNV.xy));

    	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(previousRadiance.rgb + rayPayload.radiance * INVERSE_NUMBER_OF_ITERATIONS, 1.0f));
    }
}
