//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystLightingData.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRayTracingData.glsl"

//Descriptor set data.
layout (set = 3, binding = 0, rgba32f) 	uniform image2D 	scene_image;
layout (set = 3, binding = 1, rgba8) 	uniform image2D 	scene_features_1_image;
layout (set = 3, binding = 2, rgba32f) 	uniform image2D 	scene_features_2_image;
layout (set = 3, binding = 3, rgba8) 	uniform image2D 	scene_features_3_image;
layout (set = 3, binding = 4, rg32f) 	uniform image2D 	scene_features_4_image;

//In parameters.
layout(location = 0) rayPayloadNV PathTracingRayPayload path_tracing_ray_payload;

/*
* Returns the screen coordinate with the given view matrix and world position.
*/
vec2 CalculateScreenCoordinate(mat4 givenViewMatrix, vec3 worldPosition)
{
  vec4 viewSpacePosition = givenViewMatrix * vec4(worldPosition, 1.0f);
  viewSpacePosition.xy /= viewSpacePosition.w;

  return viewSpacePosition.xy * 0.5f + 0.5f;
}

void main() 
{
	//Calculate the screen coordinate.
	vec2 screen_coordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Generate the ray direction.
	vec3 ray_direction = CalculateRayDirection(screen_coordinate);

	//Calculate if this coordinate should generate random numbers.
	//bool should_generate_random_numbers = CalculateStaleScreenCoordinate(uvec2(gl_LaunchIDNV.xy)) != uvec2(gl_LaunchIDNV.xy);
	bool should_generate_random_numbers = true;

	//Sample the noise texture.
	vec2 noise_texture_coordinate = vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY) * float(should_generate_random_numbers);
	path_tracing_ray_payload.random_noise = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex * uint(should_generate_random_numbers)], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_coordinate);

	//Sample the random hemisphere sample.
	vec3 random_hemisphere_direction;
	float random_length;

	SampleHammersleyHemisphereSample(uint(path_tracing_ray_payload.random_noise.w * 64.0f) + uint(gl_LaunchIDNV.x) + uint(gl_LaunchIDNV.y), random_hemisphere_direction, random_length);

	path_tracing_ray_payload.random_hemisphere_sample = vec4(random_hemisphere_direction, random_length);

	//Keep track of the output data.
	vec3 radiance = vec3(0.0f, 0.0f, 0.0f);
	vec3 albedo = vec3(0.0f, 0.0f, 0.0f);
	vec3 shading_normal = vec3(0.0f, 1.0f, 0.0f);
	float hit_distance = VIEW_DISTANCE;
	vec4 material_properties = vec4(0.0f, 0.0f, 0.0f, 0.0f);

	//Fire the ray(s)!
	bool has_hit = false;
	float closest_hit_distance = VIEW_DISTANCE;

	//Terrain.
	{
		//Reset the payload.
		path_tracing_ray_payload.type = CATALYST_PATH_TRACING_TYPE_TERRAIN;
		path_tracing_ray_payload.current_recursion_depth = 0;
		path_tracing_ray_payload.hit_distance = VIEW_DISTANCE;

		//Fire the ray!
		traceNV(
				TERRAIN_TOP_LEVEL_ACCELERATION_STRUCTURE,	//topLevel
				gl_RayFlagsOpaqueNV, 						//rayFlags
				0xff, 										//cullMask
				0, 											//sbtRecordOffset
				0, 											//sbtRecordStride
				0, 											//missIndex
				PERCEIVER_WORLD_POSITION, 					//origin
				CATALYST_RAY_TRACING_T_MINIMUM, 			//Tmin
				ray_direction, 								//direction
				closest_hit_distance, 						//Tmax
				0 											//payload
				);

		closest_hit_distance = min(closest_hit_distance, path_tracing_ray_payload.hit_distance);

		//Keep track of the output data.
		if (path_tracing_ray_payload.hit_distance < VIEW_DISTANCE)
		{
			has_hit = true;

			radiance = path_tracing_ray_payload.radiance;
			albedo = path_tracing_ray_payload.albedo;
			shading_normal = path_tracing_ray_payload.shading_normal;
			hit_distance = path_tracing_ray_payload.hit_distance;
			material_properties = path_tracing_ray_payload.material_properties;
		}
	}

	//Static models.
	{
		//Reset the payload.
		path_tracing_ray_payload.type = CATALYST_PATH_TRACING_TYPE_STATIC_MODELS;
		path_tracing_ray_payload.current_recursion_depth = 0;
		path_tracing_ray_payload.hit_distance = VIEW_DISTANCE;

		//Fire the ray!
		traceNV(
				STATIC_TOP_LEVEL_ACCELERATION_STRUCTURE,	//topLevel
				gl_RayFlagsOpaqueNV, 						//rayFlags
				0xff, 										//cullMask
				0, 											//sbtRecordOffset
				0, 											//sbtRecordStride
				0, 											//missIndex
				PERCEIVER_WORLD_POSITION, 					//origin
				CATALYST_RAY_TRACING_T_MINIMUM, 			//Tmin
				ray_direction, 								//direction
				closest_hit_distance, 						//Tmax
				0 											//payload
				);

		closest_hit_distance = min(closest_hit_distance, path_tracing_ray_payload.hit_distance);

		//Keep track of the output data.
		if (path_tracing_ray_payload.hit_distance < VIEW_DISTANCE)
		{
			has_hit = true;
			
			radiance = path_tracing_ray_payload.radiance;
			albedo = path_tracing_ray_payload.albedo;
			shading_normal = path_tracing_ray_payload.shading_normal;
			hit_distance = path_tracing_ray_payload.hit_distance;
			material_properties = path_tracing_ray_payload.material_properties;
		}
	}

	//Dynamic models.
	{
		//Reset the payload.
		path_tracing_ray_payload.type = CATALYST_PATH_TRACING_TYPE_DYNAMIC_MODELS;
		path_tracing_ray_payload.current_recursion_depth = 0;
		path_tracing_ray_payload.hit_distance = VIEW_DISTANCE;

		//Fire the ray!
		traceNV(
				DYNAMIC_TOP_LEVEL_ACCELERATION_STRUCTURE,	//topLevel
				gl_RayFlagsOpaqueNV, 						//rayFlags
				0xff, 										//cullMask
				0, 											//sbtRecordOffset
				0, 											//sbtRecordStride
				0, 											//missIndex
				PERCEIVER_WORLD_POSITION, 					//origin
				CATALYST_RAY_TRACING_T_MINIMUM, 			//Tmin
				ray_direction, 								//direction
				closest_hit_distance, 						//Tmax
				0 											//payload
				);

		closest_hit_distance = min(closest_hit_distance, path_tracing_ray_payload.hit_distance);

		//Keep track of the output data.
		if (path_tracing_ray_payload.hit_distance < VIEW_DISTANCE)
		{
			has_hit = true;
			
			radiance = path_tracing_ray_payload.radiance;
			albedo = path_tracing_ray_payload.albedo;
			shading_normal = path_tracing_ray_payload.shading_normal;
			hit_distance = path_tracing_ray_payload.hit_distance;
			material_properties = path_tracing_ray_payload.material_properties;
		}
	}

	//Calculate the velocity.
	vec3 hit_position = PERCEIVER_WORLD_POSITION + ray_direction * closest_hit_distance;
	vec2 velocity = CalculateScreenCoordinate(viewMatrix, hit_position) - CalculateScreenCoordinate(viewMatrixMinusOne, hit_position);

	//Calculate the depth.
	vec4 clip_space_position = viewMatrix * vec4(hit_position, 1.0f);
	float depth = clip_space_position.z / clip_space_position.w;

	//Write to the images.
	if (has_hit)
	{
		imageStore(scene_image, 			ivec2(gl_LaunchIDNV.xy), vec4(radiance, 1.0f));
		imageStore(scene_features_1_image, 	ivec2(gl_LaunchIDNV.xy), vec4(albedo, 0.0f));
		imageStore(scene_features_2_image, 	ivec2(gl_LaunchIDNV.xy), vec4(shading_normal, depth));
		imageStore(scene_features_3_image, 	ivec2(gl_LaunchIDNV.xy), material_properties);
		imageStore(scene_features_4_image, 	ivec2(gl_LaunchIDNV.xy), vec4(velocity, 0.0f, 0.0f));
	}
	
	else
	{
		imageStore(scene_image, 			ivec2(gl_LaunchIDNV.xy), vec4(texture(SKY_TEXTURES[0], ray_direction).rgb, 1.0f));
		imageStore(scene_features_1_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec3(0.0f, 0.0f, 0.0f), 0.0f));
		imageStore(scene_features_2_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec3(0.0f, 1.0f, 0.0f), depth));
		imageStore(scene_features_3_image, 	ivec2(gl_LaunchIDNV.xy), vec4(0.0f, 0.0f, 0.0f, 0.0f));
		imageStore(scene_features_4_image, 	ivec2(gl_LaunchIDNV.xy), vec4(velocity, 0.0f, 0.0f));
	}

	/*

	//Accumulate values.
	vec3 radiance = vec3(0.0f);
	vec3 albedo = vec3(0.0f);
	vec3 geometryNormal = vec3(0.0f);
	float hitDistance = 0.0f;
	vec3 shadingNormal = vec3(0.0f);
	int materialProperties = 0;
	float roughness = 0.0f;
	float metallic = 0.0f;
	float ambientOcclusion = 0.0f;
	float luminance = 0.0f;

	for (int i = 0; i < PATH_TRACING_SAMPLES; ++i)
	{
		//Jitter the screen coordinate a bit for some anti aliasing.
		vec2 jitteredScreenCoordinate = screenCoordinate + PATH_TRACING_JITTER_SAMPLES[i] * inverseScaledResolution;

		//Denote that this is the first recursion depth.
		rayPayload.currentRecursionDepth = 0;

		//Sample the noise texture.
		vec2 noiseCoordinate = vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);
		vec4 noiseSample = texture(sampler2D(GLOBAL_TEXTURES[(activeNoiseTextureIndex + i) & 63], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noiseCoordinate);

		//Write the random vector.
		rayPayload.randomVector = noiseSample;

		//Fire the ray!
		traceNV(
					topLevelAccelerationStructure, 		//topLevel
					gl_RayFlagsOpaqueNV, 				//rayFlags
					0xff, 								//cullMask
					0, 									//sbtRecordOffset
					0, 									//sbtRecordStride
					0, 									//missIndex
					PERCEIVER_WORLD_POSITION, 			//origin
					CATALYST_RAY_TRACING_T_MINIMUM, 	//Tmin
					rayDirection, 						//direction
					VIEW_DISTANCE, 						//Tmax
					0 									//payload
					);

		//Accumulate values.
		radiance += rayPayload.radiance / PATH_TRACING_SAMPLES;
		albedo += rayPayload.albedo / PATH_TRACING_SAMPLES;
		geometryNormal += rayPayload.geometryNormal / PATH_TRACING_SAMPLES;
		hitDistance += rayPayload.hitDistance / PATH_TRACING_SAMPLES;
		shadingNormal += rayPayload.shadingNormal / PATH_TRACING_SAMPLES;
		materialProperties += rayPayload.materialProperties / PATH_TRACING_SAMPLES;
		roughness += rayPayload.roughness / PATH_TRACING_SAMPLES;
		metallic += rayPayload.metallic / PATH_TRACING_SAMPLES;
		ambientOcclusion += rayPayload.ambientOcclusion / PATH_TRACING_SAMPLES;
		luminance += rayPayload.luminance / PATH_TRACING_SAMPLES;
	}

	//Write to the images.
	imageStore(sceneImage, ivec2(gl_LaunchIDNV.xy), vec4(radiance, 1.0f));
	imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), vec4(albedo, 1.0f));
	imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), vec4(geometryNormal, hitDistance));
	imageStore(sceneFeatures3Image, ivec2(gl_LaunchIDNV.xy), vec4(shadingNormal, intBitsToFloat(materialProperties)));
	imageStore(sceneFeatures4Image, ivec2(gl_LaunchIDNV.xy), vec4(roughness, metallic, ambientOcclusion, luminance));
	*/
}