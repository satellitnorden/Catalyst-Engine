//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRayTracingData.glsl"

//Descriptor set data.
layout (set = 3, binding = 0, rgba32f) 	uniform image2D 	scene_image;
layout (set = 3, binding = 1, rgba8) 	uniform image2D 	scene_features_1_image;
layout (set = 3, binding = 2, rgba32f) 	uniform image2D 	scene_features_2_image;
layout (set = 3, binding = 3, rgba8) 	uniform image2D 	scene_features_3_image;
layout (set = 3, binding = 4, rg32f) 	uniform image2D 	scene_features_4_image;

//In parameters.
layout(location = 0) rayPayloadNV PathTracingRayPayload path_tracing_ray_payload;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screen_coordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Generate the ray direction.
	vec3 ray_direction = CalculateRayDirection(screen_coordinate);

	//Sample the noise texture.
	vec2 noise_texture_coordinate = vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);
	path_tracing_ray_payload.random_noise = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_coordinate);

	//Denote that this is the first recursion depth.
	path_tracing_ray_payload.current_recursion_depth = 0;

	//Fire the ray(s)!
	bool has_hit = false;
	float closest_hit_distance = VIEW_DISTANCE;

	traceNV(
			TERRAIN_TOP_LEVEL_ACCELERATION_STRUCTURE,	//topLevel
			gl_RayFlagsOpaqueNV, 						//rayFlags
			0xff, 										//cullMask
			0, 											//sbtRecordOffset
			0, 											//sbtRecordStride
			0, 											//missIndex
			PERCEIVER_WORLD_POSITION, 					//origin
			CATALYST_RAY_TRACING_T_MINIMUM, 			//Tmin
			ray_direction, 								//direction
			closest_hit_distance, 						//Tmax
			0 											//payload
			);

	has_hit = has_hit ? true : path_tracing_ray_payload.hit_distance < VIEW_DISTANCE;
	closest_hit_distance = min(closest_hit_distance, path_tracing_ray_payload.hit_distance);

	traceNV(
			STATIC_TOP_LEVEL_ACCELERATION_STRUCTURE,	//topLevel
			gl_RayFlagsOpaqueNV, 						//rayFlags
			0xff, 										//cullMask
			0, 											//sbtRecordOffset
			0, 											//sbtRecordStride
			0, 											//missIndex
			PERCEIVER_WORLD_POSITION, 					//origin
			CATALYST_RAY_TRACING_T_MINIMUM, 			//Tmin
			ray_direction, 								//direction
			closest_hit_distance, 						//Tmax
			0 											//payload
			);

	has_hit = has_hit ? true : path_tracing_ray_payload.hit_distance < VIEW_DISTANCE;
	closest_hit_distance = min(closest_hit_distance, path_tracing_ray_payload.hit_distance);

	//Write to the images.
	if (has_hit)
	{
		imageStore(scene_image, 			ivec2(gl_LaunchIDNV.xy), vec4(path_tracing_ray_payload.radiance, 1.0f));
		imageStore(scene_features_1_image, 	ivec2(gl_LaunchIDNV.xy), vec4(path_tracing_ray_payload.albedo, 0.0f));
		imageStore(scene_features_2_image, 	ivec2(gl_LaunchIDNV.xy), vec4(path_tracing_ray_payload.shading_normal, 0.0f));
		imageStore(scene_features_3_image, 	ivec2(gl_LaunchIDNV.xy), path_tracing_ray_payload.material_properties);
		imageStore(scene_features_4_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec2(0.0f, 0.0f), 0.0f, 0.0f));
	}
	
	else
	{
		imageStore(scene_image, 			ivec2(gl_LaunchIDNV.xy), vec4(texture(SKY_TEXTURES[0], ray_direction).rgb, 1.0f));
		imageStore(scene_features_1_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec3(0.0f, 0.0f, 0.0f), 0.0f));
		imageStore(scene_features_2_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec3(0.0f, 1.0f, 0.0f), 0.0f));
		imageStore(scene_features_3_image, 	ivec2(gl_LaunchIDNV.xy), vec4(0.0f, 0.0f, 0.0f, 0.0f));
		imageStore(scene_features_4_image, 	ivec2(gl_LaunchIDNV.xy), vec4(vec2(0.0f, 0.0f), 0.0f, 0.0f));
	}

	/*

	//Accumulate values.
	vec3 radiance = vec3(0.0f);
	vec3 albedo = vec3(0.0f);
	vec3 geometryNormal = vec3(0.0f);
	float hitDistance = 0.0f;
	vec3 shadingNormal = vec3(0.0f);
	int materialProperties = 0;
	float roughness = 0.0f;
	float metallic = 0.0f;
	float ambientOcclusion = 0.0f;
	float luminance = 0.0f;

	for (int i = 0; i < PATH_TRACING_SAMPLES; ++i)
	{
		//Jitter the screen coordinate a bit for some anti aliasing.
		vec2 jitteredScreenCoordinate = screenCoordinate + PATH_TRACING_JITTER_SAMPLES[i] * inverseScaledResolution;

		//Denote that this is the first recursion depth.
		rayPayload.currentRecursionDepth = 0;

		//Sample the noise texture.
		vec2 noiseCoordinate = vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);
		vec4 noiseSample = texture(sampler2D(GLOBAL_TEXTURES[(activeNoiseTextureIndex + i) & 63], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noiseCoordinate);

		//Write the random vector.
		rayPayload.randomVector = noiseSample;

		//Fire the ray!
		traceNV(
					topLevelAccelerationStructure, 		//topLevel
					gl_RayFlagsOpaqueNV, 				//rayFlags
					0xff, 								//cullMask
					0, 									//sbtRecordOffset
					0, 									//sbtRecordStride
					0, 									//missIndex
					PERCEIVER_WORLD_POSITION, 			//origin
					CATALYST_RAY_TRACING_T_MINIMUM, 	//Tmin
					rayDirection, 						//direction
					VIEW_DISTANCE, 						//Tmax
					0 									//payload
					);

		//Accumulate values.
		radiance += rayPayload.radiance / PATH_TRACING_SAMPLES;
		albedo += rayPayload.albedo / PATH_TRACING_SAMPLES;
		geometryNormal += rayPayload.geometryNormal / PATH_TRACING_SAMPLES;
		hitDistance += rayPayload.hitDistance / PATH_TRACING_SAMPLES;
		shadingNormal += rayPayload.shadingNormal / PATH_TRACING_SAMPLES;
		materialProperties += rayPayload.materialProperties / PATH_TRACING_SAMPLES;
		roughness += rayPayload.roughness / PATH_TRACING_SAMPLES;
		metallic += rayPayload.metallic / PATH_TRACING_SAMPLES;
		ambientOcclusion += rayPayload.ambientOcclusion / PATH_TRACING_SAMPLES;
		luminance += rayPayload.luminance / PATH_TRACING_SAMPLES;
	}

	//Write to the images.
	imageStore(sceneImage, ivec2(gl_LaunchIDNV.xy), vec4(radiance, 1.0f));
	imageStore(sceneFeatures1Image, ivec2(gl_LaunchIDNV.xy), vec4(albedo, 1.0f));
	imageStore(sceneFeatures2Image, ivec2(gl_LaunchIDNV.xy), vec4(geometryNormal, hitDistance));
	imageStore(sceneFeatures3Image, ivec2(gl_LaunchIDNV.xy), vec4(shadingNormal, intBitsToFloat(materialProperties)));
	imageStore(sceneFeatures4Image, ivec2(gl_LaunchIDNV.xy), vec4(roughness, metallic, ambientOcclusion, luminance));
	*/
}