//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystPackingUtilities.glsl"
#include "CatalystShaderPhysicallyBasedLighting.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRayTracingData.glsl"
#include "CatalystRenderingUtilities.glsl"

//The random samples.
vec4 RANDOM_SAMPLES[64] = vec4[]
(
	vec4(-0.904534f, -0.301511f, 0.301511f, 0.111111f),
	vec4(-0.140028f, 0.70014f, -0.70014f, 0.555556f),
	vec4(0.6289f, -0.748691f, -0.209633f, 0.703704f),
	vec4(-0.744669f, -0.0391931f, 0.666283f, 0.259259f),
	vec4(0.151934f, 0.698898f, -0.698898f, 0.407407f),
	vec4(0.606788f, -0.793492f, 0.046676f, 0.851852f),
	vec4(-0.39013f, 0.248264f, 0.886659f, 0.0123457f),
	vec4(-0.347122f, 0.402661f, -0.846977f, 0.45679f),
	vec4(0.727046f, -0.665169f, 0.17016f, 0.901235f),
	vec4(-0.877863f, -0.228485f, 0.420893f, 0.160494f),
	vec4(-0.015469f, 0.81986f, -0.572355f, 0.604938f),
	vec4(0.720933f, -0.680317f, -0.132002f, 0.753086f),
	vec4(-0.637548f, 0.0650558f, 0.767659f, 0.308642f),
	vec4(0.206655f, 0.691843f, -0.691843f, 0.358025f),
	vec4(0.463825f, -0.882763f, -0.0748104f, 0.802469f),
	vec4(-0.51496f, 0.16328f, 0.84152f, 0.0617284f),
	vec4(-0.254355f, 0.553597f, -0.79299f, 0.506173f),
	vec4(0.809963f, -0.515431f, 0.279805f, 0.950617f),
	vec4(-0.825834f, -0.139757f, 0.546321f, 0.209877f),
	vec4(0.103086f, 0.898322f, -0.427071f, 0.654321f),
	vec4(0.682765f, -0.694288f, -0.227588f, 0.670782f),
	vec4(-0.802029f, -0.107223f, 0.587582f, 0.226337f),
	vec4(0.0982905f, 0.647361f, -0.755819f, 0.374486f),
	vec4(0.512677f, -0.857846f, -0.0355321f, 0.81893f),
	vec4(-0.472987f, 0.193308f, 0.859602f, 0.0781893f),
	vec4(-0.218268f, 0.604045f, -0.766478f, 0.522634f),
	vec4(0.828872f, -0.464743f, 0.311426f, 0.967078f),
	vec4(-0.898053f, -0.27897f, 0.340114f, 0.127572f),
	vec4(-0.0988578f, 0.744035f, -0.660786f, 0.572016f),
	vec4(0.660631f, -0.727701f, -0.18444f, 0.720165f),
	vec4(-0.711451f, -0.00436473f, 0.702722f, 0.27572f),
	vec4(0.178022f, 0.722164f, -0.668422f, 0.423868f),
	vec4(0.65038f, -0.754441f, 0.0884517f, 0.868313f),
	vec4(-0.349972f, 0.273055f, 0.896081f, 0.0288066f),
	vec4(-0.318907f, 0.452181f, -0.832965f, 0.473251f),
	vec4(0.759148f, -0.616489f, 0.208893f, 0.917695f),
	vec4(-0.863631f, -0.200559f, 0.462513f, 0.176955f),
	vec4(0.0254747f, 0.850857f, -0.52478f, 0.621399f),
	vec4(0.749041f, -0.65414f, -0.105069f, 0.769547f),
	vec4(-0.597746f, 0.0989075f, 0.795561f, 0.325103f),
	vec4(0.222122f, 0.689442f, -0.689442f, 0.341564f),
	vec4(0.414861f, -0.902933f, -0.112257f, 0.786008f),
	vec4(-0.556711f, 0.131741f, 0.820193f, 0.0452675f),
	vec4(-0.287962f, 0.502714f, -0.81508f, 0.489712f),
	vec4(0.786782f, -0.566283f, 0.245556f, 0.934156f),
	vec4(-0.84634f, -0.170936f, 0.504469f, 0.193416f),
	vec4(0.0651475f, 0.876987f, -0.476078f, 0.63786f),
	vec4(0.684969f, -0.696934f, -0.21237f, 0.687243f),
	vec4(-0.774935f, -0.0735972f, 0.627741f, 0.242798f),
	vec4(0.125301f, 0.673918f, -0.728103f, 0.390947f),
	vec4(0.560613f, -0.828062f, 0.00514324f, 0.835391f),
	vec4(-0.431245f, 0.221668f, 0.874581f, 0.0946502f),
	vec4(-0.180013f, 0.653192f, -0.735483f, 0.539095f),
	vec4(0.843816f, -0.414915f, 0.340324f, 0.983539f),
	vec4(-0.889253f, -0.254632f, 0.379989f, 0.144033f),
	vec4(-0.0571222f, 0.784133f, -0.617959f, 0.588477f),
	vec4(0.691389f, -0.704879f, -0.158514f, 0.736625f),
	vec4(-0.675607f, 0.0305113f, 0.73663f, 0.292181f),
	vec4(0.203411f, 0.743618f, -0.636911f, 0.440329f),
	vec4(0.69066f, -0.711432f, 0.129823f, 0.884774f),
	vec4(-0.311032f, 0.296042f, 0.903116f, 0.00137174f),
	vec4(-0.364428f, 0.370477f, -0.854365f, 0.445816f),
	vec4(0.703245f, -0.696333f, 0.143414f, 0.890261f),
	vec4(-0.885757f, -0.246117f, 0.393524f, 0.14952f)
);

/*
*	Scene features struct definition.
*/
struct SceneFeatures
{
	vec3 normal;
	vec3 world_position;
	vec3 view_direction;
	float roughness;
	float metallic;
};

//Descriptor set data.
layout (set = 3, binding = 0, rgba32f) uniform image2D scene_features_2_image;
layout (set = 3, binding = 1, rgba8) uniform image2D scene_features_3_image;
layout (set = 3, binding = 2, rgba32f) uniform image2D indirect_lighting_image;

//In parameters.
layout(location = 1) rayPayloadNV float visibility;

/*
*	Samples the scene features at the specified coordinates.
*/
SceneFeatures SampleSceneFeatures(ivec2 coordinate)
{
	vec4 scene_features_2 = imageLoad(scene_features_2_image, coordinate);
	vec4 scene_features_3 = imageLoad(scene_features_3_image, coordinate);

	SceneFeatures features;

	features.normal = UnpackNormal(scene_features_2.x);
	features.world_position = CalculateWorldPosition(coordinate, scene_features_2.w);
	features.view_direction = normalize(features.world_position - PERCEIVER_WORLD_POSITION);
	features.roughness = scene_features_3.x;
	features.metallic = scene_features_3.y;

	return features;
}

/*
*	Casts a ray from the given origin in the given direction and returns the irradiance.
*/
vec3 Irradiance(vec3 origin, vec3 direction)
{
	//Trace the visibility.
	visibility = 0.0f;

	traceNV(
			STATIC_TOP_LEVEL_ACCELERATION_STRUCTURE, 													//topLevel
			gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
			0xff, 																						//cullMask
			0, 																							//sbtRecordOffset
			0, 																							//sbtRecordStride
			0, 																							//missIndex
			origin, 																					//origin
			CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
			direction,																					//direction
			VIEW_DISTANCE,																				//Tmax
			1 																							//payload
			);

	//There was no hit - just return the sky color.
	return SkyColor(direction, true) * visibility + vec3(1.0f, 0.0f, 0.0f) * (1.0f - visibility);
}

/*
*	Samples the random direction and length.
*/
void SampleRandomDirectionAndLength(vec3 normal, out vec3 direction, out float length)
{
	//Calculate the noise texture coordinate.
	vec2 noise_texture_coordinate = vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY);

	//Calculate the random rotation matrix.
	vec4 random_sample = texture(sampler2D(GLOBAL_TEXTURES[activeNoiseTextureIndex], GLOBAL_SAMPLERS[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), noise_texture_coordinate);

	vec3 random_normal = random_sample.xyz * 2.0f - 1.0f;
	vec3 random_tangent = normalize(random_normal - normal * dot(random_normal, normal));
	vec3 random_bitangent = cross(random_normal, random_tangent);

	mat3 random_rotation = mat3(random_tangent, random_bitangent, random_normal);

	//Take the random sample.
	vec4 random_direction_and_length_sample = RANDOM_SAMPLES[(gl_LaunchIDNV.x + gl_LaunchIDNV.y + int(random_sample.w * 64.0f)) & 63];

	//Apply the random rotation.
	random_direction_and_length_sample.xyz = random_rotation * random_direction_and_length_sample.xyz;

	//Write the random direction and length.
	direction = random_direction_and_length_sample.xyz;
	length = random_direction_and_length_sample.w;
}

void main()
{
	//Sample the current features.
	SceneFeatures current_features = SampleSceneFeatures(ivec2(gl_LaunchIDNV.xy));

	//Calculate the ray direction.
	vec3 specular_direction = reflect(current_features.view_direction, current_features.normal);
	vec3 diffuse_direction;
	float random_length;
	SampleRandomDirectionAndLength(current_features.normal, diffuse_direction, random_length);
	diffuse_direction = dot(diffuse_direction, current_features.normal) >= 0.0f ? diffuse_direction : diffuse_direction * -1.0f;

	vec3 ray_direction = normalize(mix(specular_direction, diffuse_direction, current_features.roughness * (1.0f - current_features.metallic)));

	//Cast the ray!
	vec3 irradiance = Irradiance(current_features.world_position + ray_direction * 0.01f, ray_direction);

	//Write to the image.
	imageStore(indirect_lighting_image, ivec2(gl_LaunchIDNV.xy), vec4(irradiance, 1.0f));
}