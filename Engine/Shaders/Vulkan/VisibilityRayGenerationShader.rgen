//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystLightingData.glsl"
#include "CatalystModelData.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRenderingUtilities.glsl"

//Constants.
#define VISIBILITY_SAMPLES (4)

//Push constant data.
layout (push_constant) uniform PushConstantData
{
    layout (offset = 0) int lightIndex;
};

//Descriptor set data.
layout (set = 3, binding = 0) uniform sampler2D sceneFeatures2Texture;
layout (set = 3, binding = 1, r8) uniform image2D visibilityImage;

//In parameters.
layout(location = 1) rayPayloadNV float visibility;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screenCoordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Generate the ray direction.
	vec3 rayDirection = CalculateRayDirection(screenCoordinate);

	//Load the scene features.
	vec4 sceneFeatures2 = texture(sceneFeatures2Texture, screenCoordinate);

	//Retrieve all properties.
	vec3 geometryNormal = sceneFeatures2.xyz;
	float hitDistance = sceneFeatures2.w;

	//Calculate the hit position.
	vec3 hitPosition = perceiverWorldPosition + rayDirection * hitDistance + geometryNormal * 0.001f;

	//Unpack the relevant light.
	Light light = UnpackLight(lightIndex);

	//Calculate the final visibility.
	float finalVisibility = 0.0f;

	for (int i = 0; i < VISIBILITY_SAMPLES; ++i)
	{
		//Retrieve the random properties.
		vec4 randomVector = texture(sampler2D(globalTextures[(activeNoiseTextureIndex + i) & 63], globalSamplers[GLOBAL_SAMPLER_FILTER_NEAREST_MIPMAP_MODE_NEAREST_ADDRESS_MODE_REPEAT_INDEX]), vec2(gl_LaunchIDNV.xy) / 64.0f + vec2(activeNoiseTextureOffsetX, activeNoiseTextureOffsetY));
		vec3 randomPosition = normalize(randomVector.xyz * 2.0f - 1.0f);

		//Calculate the random light position.
		vec3 randomLightPosition = light.position + randomPosition * light.size;

		//Calculate the visibility for the light.
		float lengthToLight = length(randomLightPosition - hitPosition);
		vec3 lightDirection = vec3(randomLightPosition - hitPosition) / lengthToLight;

		visibility = 0.0f;

		traceNV(
				topLevelAccelerationStructure, 																//topLevel
				gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
				0xff, 																						//cullMask
				0, 																							//sbtRecordOffset
				0, 																							//sbtRecordStride
				0, 																							//missIndex
				hitPosition, 																				//origin
				CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
				lightDirection,																				//direction
				lengthToLight,																				//Tmax
				1 																							//payload
				);

		finalVisibility += visibility;
	}

	//Normalize the final visibility.
	finalVisibility /= VISIBILITY_SAMPLES;

	//Write to the image.
	imageStore(visibilityImage, ivec2(gl_LaunchIDNV.xy), vec4(finalVisibility, 0.0f, 0.0f, 1.0f));
}