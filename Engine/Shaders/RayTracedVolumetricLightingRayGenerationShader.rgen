//Includes.
#include "CatalystGeometryMath.glsl"
#define CATALYST_LIGHTING_DATA_SET_INDEX (2)
#include "CatalystLightingData.glsl"
#include "CatalystRayTracingData.glsl"
#include "..\Include\Rendering\Native\Shader\CatalystLighting.h"
#include "..\Include\Rendering\Native\Shader\CatalystVolumetricLighting.h"

//Constants.
#define NUMBER_OF_DIRECTIONAL_LIGHT_SAMPLES (2)
#define NUMBER_OF_POINT_LIGHT_SAMPLES (2)

//Descriptor set data.
layout (set = 3, binding = 0) uniform sampler2D scene_features_2_texture;
layout (set = 3, binding = 1, rgba32f) uniform image2D volumetric_lighting_image;

//In parameters.
layout(location = 1) rayPayloadNV float visibility;

/*
*	Returns a dithered sample offset.
*/
float GetDitheredSampleOffset(vec4 sample_offsets, uint index)
{
	float actual_sample_offset = sample_offsets[index & 3];
	float dither_sample_offset = sample_offsets[(index + 1) & 3];

	return actual_sample_offset + mix(-0.0039211568627450f, 0.0039211568627450f, dither_sample_offset);
}

void CatalystShaderMain() 
{
	//Calculate the screen coordinate.
	vec2 screen_coordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Load the scene features.
	vec4 scene_features_2 = texture(scene_features_2_texture, screen_coordinate);

	//Retrieve all properties.
	vec3 world_position = CalculateWorldPosition(screen_coordinate, scene_features_2.w);
	float hit_distance = length(world_position - PERCEIVER_WORLD_POSITION);
	float hit_distance_reciprocal = 1.0f / hit_distance;

	//Generate the ray direction.
	vec3 ray_direction = (world_position - PERCEIVER_WORLD_POSITION) * hit_distance_reciprocal;

	//Calculate the volumetric lighting.
	vec3 volumetric_lighting = vec3(0.0f);

	//Add the ambient lighting.
	volumetric_lighting += CalculateVolumetricAmbientLighting();

	//Sample the offsets.
	vec4 sample_offsets = SampleBlueNoiseTexture(uvec2(gl_LaunchIDNV.xy), 0);

	//Calculate the volumetric lighting for all volumetric lights.
	uint current_sample_offset_index = 0;

	for (uint i = 0; i < NUMBER_OF_LIGHTS; ++i)
	{
		//Unpack the light.
		Light light = UnpackLight(i);

		if (TEST_BIT(light.light_properties, LIGHT_PROPERTY_VOLUMETRIC_BIT))
		{
			switch (light.light_type)
			{
				case LIGHT_TYPE_DIRECTIONAL:
				{
					for (uint sample_index = 0; sample_index < NUMBER_OF_DIRECTIONAL_LIGHT_SAMPLES; ++sample_index)
					{
						//Calculate the volumetric particle hit distance.
						float volumetric_particle_hit_distance = min(hit_distance, VOLUMETRIC_LIGHTING_DISTANCE) * GetDitheredSampleOffset(sample_offsets, current_sample_offset_index++);

						//Calculate the volumetric particle hit position.
						vec3 volumetric_particle_hit_position = PERCEIVER_WORLD_POSITION + ray_direction * volumetric_particle_hit_distance;

						//Determine the visibility.
						bool hit_anything = false;

						if (TEST_BIT(light.light_properties, LIGHT_PROPERTY_VOLUMETRIC_SHADOW_CASTING_BIT))
						{
							visibility = 0.0f;

							traceNV(
									TOP_LEVEL_ACCELERATION_STRUCTURE, 															//topLevel
									gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
									0xff, 																						//cullMask
									0, 																							//sbtRecordOffset
									0, 																							//sbtRecordStride
									0, 																							//missIndex
									volumetric_particle_hit_position, 															//origin
									0.0f, 																						//Tmin
									-light.position_or_direction,																//direction
									VIEW_DISTANCE,																				//Tmax
									1 																							//payload
									);

							hit_anything = visibility < 1.0f;
						}

						//Calculate the light to volumetric particle opacity.
						float light_to_volumetric_particle_opacity = CalculateVolumetricLightingOpacity(FLOAT32_MAXIMUM, VOLUMETRIC_LIGHTING_DISTANCE, FLOAT32_MAXIMUM, VOLUMETRIC_LIGHTING_HEIGHT, VOLUMETRIC_LIGHTING_THICKNESS, volumetric_particle_hit_position.y);

						//Calculate the volumetric particle to perceiver opacity.
						float volumetric_particle_to_perceiver_opacity = CalculateVolumetricLightingOpacity(volumetric_particle_hit_distance, VOLUMETRIC_LIGHTING_DISTANCE, volumetric_particle_hit_position.y, VOLUMETRIC_LIGHTING_HEIGHT, VOLUMETRIC_LIGHTING_THICKNESS, PERCEIVER_ABSOLUTE_HEIGHT);

						//Add to the volumetric lighting.
						volumetric_lighting += VOLUMETRIC_LIGHTING_BASE_COLOR * light.color * light.intensity * (1.0f - light_to_volumetric_particle_opacity) * (1.0f - volumetric_particle_to_perceiver_opacity) * float(!hit_anything) / float(NUMBER_OF_DIRECTIONAL_LIGHT_SAMPLES);
					}

					break;
				}

				case LIGHT_TYPE_POINT:
				{
					//Do a ray/sphere intersection to determine the volumetric particle hit distance.
					Ray ray;

					ray._Origin = PERCEIVER_WORLD_POSITION;
					ray._Direction = ray_direction;

					Sphere sphere;

					sphere._Position = light.position_or_direction;
					sphere._Radius = light.radius;

					RaySphereIntersectionResult result = RaySphereIntersection(ray, sphere);

					if (result._Result != RAY_SPHERE_INTERSECTION_RESULT_NO_HIT)
					{
						for (uint sample_index = 0; sample_index < NUMBER_OF_POINT_LIGHT_SAMPLES; ++sample_index)
						{
							float volumetric_particle_hit_distance;

							switch (result._Result)
							{
								case RAY_SPHERE_INTERSECTION_RESULT_ONE_HIT:
								{
									volumetric_particle_hit_distance = mix(0.0f, min(result._ClosestHitDistance, hit_distance), GetDitheredSampleOffset(sample_offsets, current_sample_offset_index++));

									break;
								}

								case RAY_SPHERE_INTERSECTION_RESULT_TWO_HITS:
								{
									volumetric_particle_hit_distance = mix(min(result._ClosestHitDistance, hit_distance), min(result._FarthestHitDistance, hit_distance), GetDitheredSampleOffset(sample_offsets, current_sample_offset_index++));
									
									break;
								}
							}

							//Calculate the volumetric particle hit position.
							vec3 volumetric_particle_hit_position = ray._Origin + ray._Direction * volumetric_particle_hit_distance;

							//Calculate the distance to the light.
							float distance_to_light = length(light.position_or_direction - volumetric_particle_hit_position);

							//Calculate the reciprocal of the distance to light.
							float distance_to_light_reciprocal = 1.0f / distance_to_light;

							//Calculate the attenuation.
							float attenuation = CalculateAttenuation(distance_to_light, light.radius);

							//Determine the visibility.
							bool hit_anything = false;

							if (TEST_BIT(light.light_properties, LIGHT_PROPERTY_VOLUMETRIC_SHADOW_CASTING_BIT))
							{
								//Calculate the direction to the light.
								vec3 direction_to_light = vec3(light.position_or_direction - volumetric_particle_hit_position) * distance_to_light_reciprocal;

								visibility = 0.0f;

								traceNV(
										TOP_LEVEL_ACCELERATION_STRUCTURE, 															//topLevel
										gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
										0xff, 																						//cullMask
										0, 																							//sbtRecordOffset
										0, 																							//sbtRecordStride
										0, 																							//missIndex
										volumetric_particle_hit_position, 															//origin
										0.0f, 																						//Tmin
										direction_to_light,																			//direction
										distance_to_light,																			//Tmax
										1 																							//payload
										);

								hit_anything = visibility < 1.0f;
							}

							//Calculate the light to volumetric particle opacity.
							float light_to_volumetric_particle_opacity = CalculateVolumetricLightingOpacity(distance_to_light, VOLUMETRIC_LIGHTING_DISTANCE, light.position_or_direction.y, VOLUMETRIC_LIGHTING_HEIGHT, VOLUMETRIC_LIGHTING_THICKNESS, volumetric_particle_hit_position.y);

							//Calculate the volumetric particle to perceiver opacity.
							float volumetric_particle_to_perceiver_opacity = CalculateVolumetricLightingOpacity(volumetric_particle_hit_distance, VOLUMETRIC_LIGHTING_DISTANCE, volumetric_particle_hit_position.y, VOLUMETRIC_LIGHTING_HEIGHT, VOLUMETRIC_LIGHTING_THICKNESS, PERCEIVER_ABSOLUTE_HEIGHT);

							//Add to the volumetric lighting.
							volumetric_lighting += VOLUMETRIC_LIGHTING_BASE_COLOR * light.color * light.intensity * attenuation * (1.0f - light_to_volumetric_particle_opacity) * (1.0f - volumetric_particle_to_perceiver_opacity) * float(!hit_anything) / float(NUMBER_OF_POINT_LIGHT_SAMPLES);
						}
					}

					break;
				}
			}
		}
	}

	//Write to the image.
	imageStore(volumetric_lighting_image, ivec2(gl_LaunchIDNV.xy), vec4(volumetric_lighting, 1.0f));
}