//Version declaration.
#version 460

//Extensions.
#extension GL_GOOGLE_include_directive : enable

//Includes.
#include "CatalystShaderCommon.glsl"
#include "CatalystGeometryMath.glsl"
#include "CatalystLightingData.glsl"
#include "CatalystPackingUtilities.glsl"
#include "CatalystRayTracingCore.glsl"
#include "CatalystRayTracingData.glsl"
#include "CatalystRenderingUtilities.glsl"
#include "CatalystShaderPhysicallyBasedLighting.glsl"
#include "..\Include\Rendering\Native\Shader\CatalystLighting.h"

//Constants.
#define CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR (vec3(0.6f, 0.8f, 1.0f))
#define CATALYST_VOLUMETRIC_LIGHTING_DENSITY_MULTIPLIER (0.125f)

//Descriptor set data.
layout (set = 3, binding = 0) uniform sampler2D scene_features_2_texture;
layout (set = 3, binding = 1, rgba32f) uniform image2D volumetric_lighting_image;

//In parameters.
layout(location = 1) rayPayloadNV float visibility;

void main() 
{
	//Calculate the screen coordinate.
	vec2 screen_coordinate = (vec2(gl_LaunchIDNV.xy) + vec2(0.5f)) / vec2(gl_LaunchSizeNV.xy);

	//Load the scene features.
	vec4 scene_features_2 = texture(scene_features_2_texture, screen_coordinate);

	//Retrieve all properties.
	vec3 world_position = CalculateWorldPosition(screen_coordinate, scene_features_2.w);
	float hit_distance = length(world_position - PERCEIVER_WORLD_POSITION);

	//Generate the ray direction.
	vec3 ray_direction = (world_position - PERCEIVER_WORLD_POSITION) / hit_distance;

	//Calculate the volumetric lighting.
	vec3 volumetric_lighting = vec3(0.0f);

	//Add the ambient lighting.
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(-1.0f, 0.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(1.0f, 0.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, -1.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 1.0f, 0.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 0.0f, -1.0f)).rgb * 0.167;
	volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * texture(SKY_TEXTURES[NUMBER_OF_SKY_TEXTURES - 1], vec3(0.0f, 0.0f, 1.0f)).rgb * 0.167;

	//Sample the noise texture.
	vec4 noise_texture = SampleBlueNoiseTexture(uvec2(gl_LaunchIDNV.xy), 0);

	float samples_offsets[4];

	samples_offsets[0] = noise_texture[0];
	samples_offsets[1] = noise_texture[1];
	samples_offsets[2] = noise_texture[2];
	samples_offsets[3] = noise_texture[3];

	uint current_sample_offset_index = 0;

	//Calculate the volumetric lighting for all volumetric lights.
	for (int i = 0; i < NUMBER_OF_LIGHTS; ++i, ++current_sample_offset_index)
	{
		//Unpack the light.
		Light light = UnpackLight(i);

		if (TEST_BIT(light.light_properties, LIGHT_PROPERTY_VOLUMETRIC_BIT))
		{
			switch (light.light_type)
			{
				case LIGHT_TYPE_DIRECTIONAL:
				{
					//Calculate the volumetric particle hit distance.
					float volumetric_particle_hit_distance = hit_distance * samples_offsets[current_sample_offset_index & 3];

					//Calculate the volumetric particle hit position.
					vec3 volumetric_particle_hit_position = PERCEIVER_WORLD_POSITION + ray_direction * volumetric_particle_hit_distance;

					//Determine the visibility.
					bool hit_anything = false;

					if (TEST_BIT(light.light_properties, LIGHT_PROPERTY_VOLUMETRIC_SHADOW_CASTING_BIT))
					{
						visibility = 0.0f;

						traceNV(
								TOP_LEVEL_ACCELERATION_STRUCTURE, 															//topLevel
								gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV | gl_RayFlagsSkipClosestHitShaderNV, //rayFlags
								0xff, 																						//cullMask
								0, 																							//sbtRecordOffset
								0, 																							//sbtRecordStride
								0, 																							//missIndex
								volumetric_particle_hit_position, 															//origin
								CATALYST_RAY_TRACING_T_MINIMUM, 															//Tmin
								-light.position_or_direction,																//direction
								VIEW_DISTANCE,																				//Tmax
								1 																							//payload
								);

						hit_anything = visibility < 1.0f;
					}

					//Add to the volumetric lighting.
					volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * light.color * light.intensity * CATALYST_VOLUMETRIC_LIGHTING_DENSITY_MULTIPLIER * float(!hit_anything);

					break;
				}

				case LIGHT_TYPE_POINT:
				{
					//Do a ray/sphere intersection to determine the volumetric particle hit distance.
					Ray ray;

					ray._Origin = PERCEIVER_WORLD_POSITION;
					ray._Direction = ray_direction;

					Sphere sphere;

					sphere._Position = light.position_or_direction;
					sphere._Radius = light.radius;

					RaySphereIntersectionResult result = RaySphereIntersection(ray, sphere);

					if (result._Result != RAY_SPHERE_INTERSECTION_RESULT_NO_HIT)
					{
						float volumetric_particle_hit_distance;

						switch (result._Result)
						{
							case RAY_SPHERE_INTERSECTION_RESULT_ONE_HIT:
							{
								volumetric_particle_hit_distance = mix(0.0f, result._ClosestHitDistance, samples_offsets[current_sample_offset_index & 3]);

								break;
							}

							case RAY_SPHERE_INTERSECTION_RESULT_TWO_HITS:
							{
								volumetric_particle_hit_distance = mix(result._ClosestHitDistance, result._FarthestHitDistance, samples_offsets[current_sample_offset_index & 3]);
								
								break;
							}
						}

						if (volumetric_particle_hit_distance < hit_distance)
						{
							//Calculate the volumetric particle hit position.
							vec3 volumetric_particle_hit_position = ray._Origin + ray._Direction * volumetric_particle_hit_distance;

							//Determine the distance to the light.
							float distance_to_light = length(light.position_or_direction - volumetric_particle_hit_position);

							//Calculate the attenuation.
							float attenuation = CalculateAttenuation(distance_to_light, light.radius);

							//Add to the volumetric lighting.
							volumetric_lighting += CATALYST_VOLUMETRIC_LIGHTING_BASE_COLOR * light.color * light.intensity * CATALYST_VOLUMETRIC_LIGHTING_DENSITY_MULTIPLIER * attenuation;
						}
					}

					break;
				}
			}
		}
	}

	//Write to the image.
	imageStore(volumetric_lighting_image, ivec2(gl_LaunchIDNV.xy), vec4(volumetric_lighting, 1.0f));
}