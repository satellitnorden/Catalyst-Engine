#pragma once

namespace HashAlgorithms
{

	/*
	*	Given arbitrary data and a length of the data, specified in bytes, returns a 64-bit hashed value.
	*	Uses the Catalyst Engine's own hashing algorithm.
	*/
	static constexpr uint64 CatalystHash(const void *const RESTRICT data, const uint64 length) NOEXCEPT
	{
		//Defines the table of randomly pregenerated 64-bit values that is used in the mixing step.
		static constexpr uint64 randomTable[256]
		{
			17560930965631933617,
			9878389245448494471,
			7123207422871460316,
			6698490550206600215,
			9237603597315756049,
			12722304790779024227,
			10168806444686865565,
			16285218618110221225,
			14127781781355445864,
			16706438048241833235,
			14464401887428085303,
			16579578339588149880,
			6942338271136362943,
			16245062713127040960,
			5999197467307359585,
			5917387243795852351,
			6567527800446256564,
			5761816604579013021,
			17400772023355560990,
			5273102312404278468,
			4825053491189533542,
			5904959865574041029,
			4889189317970114367,
			3488005562488628376,
			2121092745091322887,
			9059212359729980553,
			4442338194285452607,
			15117033522949622184,
			1458304701614515527,
			437080939375235345,
			9713084737376650878,
			12556364091623256880,
			629526290968010433,
			7109881675154368976,
			8079449294824467805,
			4210613093758892982,
			16685686997581889613,
			7484488847049490381,
			55550918462184376,
			2046934102092302774,
			7878763160060843423,
			15527813280429559639,
			386851097423212803,
			6535797858248330869,
			5423499223124499027,
			8425043641261968359,
			1630309645080150463,
			4573091028862423225,
			9531278009924459613,
			2902555699688352993,
			5430040719693447842,
			8463221362061156698,
			18079439368152049660,
			17481576187591344632,
			15258782866438137765,
			13671043426869992539,
			11523974334480015284,
			2242684098709626479,
			1603581146017372540,
			13930984894239873454,
			6454235925450647192,
			8042921848422548862,
			17021743764326421699,
			17660205641301376799,
			18345960330194627008,
			10739049733917709181,
			5819599072956005704,
			16715787726674004790,
			10098674264774589280,
			7335259469627022024,
			5586743101090900325,
			16909226101384191449,
			8456344613471931049,
			1702089858021400761,
			10502337575256943561,
			11342508755000169717,
			13419610813988877866,
			9145853618156203000,
			15297192116476679531,
			5334826950151293876,
			4441628924317161225,
			5595227637178392561,
			11634246325195094389,
			18431120865783043506,
			6433708343870734073,
			11923891671214093118,
			17292019166095057658,
			3903761957218636057,
			7571174660802980829,
			16336788816291233552,
			1616053025093478843,
			14221530156006716009,
			8885873772994714320,
			1503468572789489100,
			7932692404711885073,
			3023380487341274199,
			6027865223932014067,
			14618944186979899246,
			7374149712926027258,
			9899615458023758499,
			15645626340599618779,
			13038828797915336173,
			3343292409014951839,
			12284007219927916801,
			7623155688078502817,
			10130196601614046266,
			139524192823030337,
			13982651473474441254,
			8458957429409283487,
			3150880015742192015,
			16491526491584716781,
			441383822570780277,
			14395947883029623279,
			16176729819131575022,
			12631400571397848932,
			477696502127384991,
			18111543051088346010,
			7301110232659242906,
			5021042578144855442,
			5559965715883244721,
			4818369469476311287,
			5673267995010496719,
			3131441627842406220,
			3157805480291616952,
			12468739066043259038,
			14520272622262618344,
			12200478646907301935,
			17972731949073123118,
			6363439102129774495,
			3029430450490758832,
			9193354786883952988,
			231613257057551906,
			5699602898195495711,
			13152013893290532427,
			16969264609051194218,
			15781363309394362734,
			16499644598354659592,
			4134221085285872712,
			5768377975636145591,
			11343724794510637935,
			9516506914304647632,
			16244724826618111628,
			2938660290701361526,
			270373338765637592,
			16240695788612074641,
			10688811985406375394,
			13194179790656822243,
			795896873785436423,
			12278686837318321663,
			16062393251605163499,
			15316711656562544220,
			11256582052759458820,
			14069231963854362226,
			10099326549293633216,
			3285504040772588683,
			4083196111133406086,
			9357152923138465588,
			2740055713841083069,
			7596912462954479253,
			15808642734361812210,
			14672499501134105388,
			3185000875032109346,
			7981343786475614476,
			14976414755787503311,
			13760825524207499899,
			4802442425895954020,
			11184182672562818620,
			11930758450393804920,
			15385392137856142917,
			14360222137396784768,
			5021000807680764291,
			8147842345265562422,
			683328664264105926,
			17032902170503547258,
			2315611460452587777,
			16209669469918845303,
			12238257316779748139,
			16492927976952858421,
			11746954235584597083,
			17448698143922352388,
			10224459365132228068,
			15610780510487898405,
			555397559573470958,
			3200040278766167449,
			13621731200257105059,
			13658911007573174888,
			4947041075210717727,
			15664614996667553260,
			16262648131803621244,
			13675858870192689714,
			5387394292628478745,
			2431913351323671724,
			10385359613925650346,
			5027019375344491316,
			16999489862911890799,
			14327761695570564117,
			15906911084456499735,
			2310744715197719042,
			16817715175396358130,
			7788773128024837938,
			16346007038775322793,
			9574699190750158950,
			11094202584864470966,
			5485529148679679365,
			12073209595404636942,
			6804300515681679052,
			15646963769387501335,
			13231633774834277183,
			3977649630609396415,
			9007942203254162378,
			18347901722589457699,
			14803917054395996681,
			6842498892724525893,
			11370231912640114008,
			16293070536396496206,
			10813581543748995520,
			8924463008898768742,
			299017367097661342,
			13681999915919429722,
			14676538330499685604,
			15855402473737452315,
			10735514207718494340,
			17586422898649520138,
			6843651765758058097,
			9617216232026421895,
			10399277233902024095,
			12736377535140326080,
			13371140394543587478,
			15735123989542841806,
			2047191309885259279,
			7409861310296529474,
			9990111466832781446,
			13624044273613610664,
			3474038971823852255,
			5664058380916814672,
			7259945411997285368,
			17451065295276712581,
			1966762466573869896,
			3103304002335441231,
			16174273197300480942,
			15886003863429191327,
			8923646403357828608,
			3647356717218173353,
			11380199030156496062,
			7118193621894595080,
			3004255291799261373,
			9069001090692446168,
			11151500216389048467,
			11436382684436066291,
			11558553152582577279,
			7088991897746320725,
			240062035296455618,
			4719602276927472541,
			5211034984813859333,
			8501398579569192760,
		};

		//Treat the data as a stream of bytes.
		const byte *const RESTRICT byteData{ reinterpret_cast<const byte *const RESTRICT>(data) };

		//Set up the hash's initial value.
		uint64 hash{ 0 };

		//For each byte, mutate the hash.
		for (uint64 i = 0; i < length; ++i)
		{
			const byte byte{ byteData[i] };

			//Fill the hash bits up with data at the "beginning" and then shift those bits towards the "end",
			//filling up the "beginning" with different bits based on the input byte.
			hash += byte;
			hash = hash << 3;
			hash += byte ^ UINT8_MAXIMUM;
			hash = hash << 5;
			hash += hash / byte;
			hash = hash << 7;
			hash += hash * byte;

			//Shift the bits of the input byte a random number of steps to the left
			//in the range of 0-64 and flip the bits of the hash at those positions.
			hash ^= (static_cast<uint64>(byte) << (byte / 5));
			hash ^= (static_cast<uint64>(byte) << ((byte ^ UINT8_MAXIMUM) / 6));
			hash ^= (static_cast<uint64>(byte ^ UINT8_MAXIMUM) << (byte / 7));
			hash ^= (static_cast<uint64>(byte ^ UINT8_MAXIMUM) << ((byte ^ UINT8_MAXIMUM) / 8));

			//Use the input byte, as well as the current hash forced into a 0-256 range,
			//as an index into the table of randomly pregenerated 64-bit values,
			//and use that value to flip certain bits of the hash.
			hash ^= randomTable[byte];
			hash ^= randomTable[hash % UINT8_MAXIMUM];
			hash ^= randomTable[byte ^ UINT8_MAXIMUM];
			hash ^= randomTable[hash % UINT8_MAXIMUM];
		}

		return hash;
	}

	/*
	*	Given arbitrary data and a length of the data, specified in bytes, returns a 64-bit hashed value.
	*	Uses the DJB2 hashing algorithm.
	*/
	static constexpr uint64 DJB2Hash(const void *const RESTRICT data, const uint64 length) NOEXCEPT
	{
		//Treat the data as a stream of bytes.
		const byte *const RESTRICT byteData{ reinterpret_cast<const byte *const RESTRICT>(data) };

		//Set up the hash's initial value.
		uint64 hash{ 5381 };

		//For each byte, mutate the hash.
		for (uint64 i = 0; i < length; ++i)
		{
			const byte byte{ byteData[i] };

			hash = ((hash << 5) + hash) + byte;
		}

		return hash;
	}

	/*
	*	Given arbitrary data and a length of the data, specified in bytes, returns a 64-bit hashed value.
	*	Uses the Jenkins hashing algorithm.
	*/
	static constexpr uint64 JenkinsHash(const void *const RESTRICT data, uint64 length) NOEXCEPT
	{
		//Define the mix function.
		#define mix(a,b,c)					\
		{									\
			a -= b; a -= c; a ^= (c >> 13); \
			b -= c; b -= a; b ^= (a << 8);	\
			c -= a; c -= b; c ^= (b >> 13); \
			a -= b; a -= c; a ^= (c >> 12); \
			b -= c; b -= a; b ^= (a << 16); \
			c -= a; c -= b; c ^= (b >> 5);	\
			a -= b; a -= c; a ^= (c >> 3);	\
			b -= c; b -= a; b ^= (a << 10); \
			c -= a; c -= b; c ^= (b >> 15); \
		}

		//Treat the data as a stream of bytes.
		const byte *RESTRICT byteData{ reinterpret_cast<const byte *RESTRICT>(data) };

		//Set up the hash's initial value.
		uint64 a{ 0x9e3779b };
		uint64 b{ a };
		uint64 hash{ 0 };

		while (length >= 12)
		{
			a += (byteData[0] + (static_cast<uint64>(byteData[1]) << 8) + (static_cast<uint64>(byteData[2]) << 16) + (static_cast<uint64>(byteData[3]) << 24));
			b += (byteData[4] + (static_cast<uint64>(byteData[5]) << 8) + (static_cast<uint64>(byteData[6]) << 16) + (static_cast<uint64>(byteData[7]) << 24));
			hash += (byteData[8] + (static_cast<uint64>(byteData[9]) << 8) + (static_cast<uint64>(byteData[10]) << 16) + (static_cast<uint64>(byteData[11]) << 24));

			mix(a, b, hash);

			byteData += 12;
			length -= 12;
		}

		hash += length;

		switch (length)
		{
			case 11: hash += (static_cast<uint64>(byteData[10]) << 24);
			case 10: hash += (static_cast<uint64>(byteData[9]) << 16);
			case 9: hash += (static_cast<uint64>(byteData[8]) << 8);
			case 8: b += (static_cast<uint64>(byteData[7]) << 24);
			case 7: b += (static_cast<uint64>(byteData[6]) << 16);
			case 6: b += (static_cast<uint64>(byteData[5]) << 8);
			case 5: b += byteData[4];
			case 4: a += (static_cast<uint64>(byteData[3]) << 24);
			case 3: a += (static_cast<uint64>(byteData[2]) << 16);
			case 2: a += (static_cast<uint64>(byteData[1]) << 8);
			case 1: a += byteData[0];
		}

		mix(a, b, hash);

		return hash;
	}

}